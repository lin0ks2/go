

(function(){
  const App = window.App = (window.App||{});
  App.APP_VER = '1.3.5';

  const LS_SETTINGS = 'k_settings_v1_3_1';
  const LS_STATE    = 'k_state_v1_3_1';
  const LS_DICTS    = 'k_dicts_v1_3_1';

  // Fallback + external
  const I18N_FALLBACK = window.I18N;

  App.settings = loadSettings();
  App.state = loadState() || {
    index:0,lastIndex:-1,favorites:{},stars:{},successes:{},
    lastShownWordId:null, totals:{shown:0,errors:0}, lastSeen:{}
  };
  App.dictRegistry = loadDictRegistrySafe();

  // ── миграция под наборы: setSize=50 по умолчанию, map под активные наборы ──
  (function migrateSets(){
    let ss = 50;
    try { ss = Number(App.state.setSize); } catch(e){}
    if (!Number.isFinite(ss) || ss < 2) ss = 50;
    App.state.setSize = ss;

    if (!App.state.setByDeck || typeof App.state.setByDeck !== 'object'){
      App.state.setByDeck = {};
    }
    // сохранять сразу не обязательно; сохраним при первых изменениях
  })();

  App.i18n = function(){
    const lang = App.settings.lang || 'uk';
    const base = (I18N_FALLBACK && I18N_FALLBACK[lang]) ? I18N_FALLBACK[lang] : I18N_FALLBACK.uk;
    return base;
  };

  App.clamp = (n,min,max)=>Math.max(min,Math.min(max,n));
  App.shuffle = (a)=>{const arr=a.slice();for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];}return arr;};
  App.escapeHtml = (s)=>String(s).replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));

  function loadSettings(){ try{ const raw=localStorage.getItem(LS_SETTINGS); if(raw) return Object.assign({lang:'uk',theme:'auto',repeats:6}, JSON.parse(raw)); }catch(e){} return {lang:'uk',theme:'auto',repeats:6}; }
  App.saveSettings = function(s){ try{ localStorage.setItem(LS_SETTINGS, JSON.stringify(s)); }catch(e){} };

  function loadState(){ try{ const raw=localStorage.getItem(LS_STATE); if(raw) return JSON.parse(raw);}catch(e){} return null; }
  App.saveState = function(){ try{ localStorage.setItem(LS_STATE, JSON.stringify(App.state)); }catch(e){} };

  function loadDictRegistrySafe(){ try{ const raw=localStorage.getItem(LS_DICTS); if(raw) return JSON.parse(raw);}catch(e){} return { activeKey:null, user:{} }; }
  App.saveDictRegistry = function(){ try{ localStorage.setItem(LS_DICTS, JSON.stringify(App.dictRegistry)); }catch(e){} };

  // DOM map
  App.DOM = {
    titleEl:document.getElementById('title'),
    appVerEl:document.getElementById('appVer'),
    taglineEl:document.getElementById('tagline'),
    wordEl:document.getElementById('wordText'),
    hintEl:document.getElementById('hintText'),
    optionsRow:document.getElementById('optionsRow'),
    favBtn:document.getElementById('favBtn'),
    starsEl:document.getElementById('stars'),
    statsBar:document.getElementById('statsBar'),
    copyYearEl:document.getElementById('copyYear'),
    // header controls
    themeToggleBtn:document.getElementById('themeToggleBtn'),
    langToggleBtn:document.getElementById('langToggleBtn'),
    dictsBtn:document.getElementById('dictsBtn'),
    modalTitleEl:document.getElementById('modalTitle'),
    langFlags:document.getElementById('langFlags'),
    // modal
    modal:document.getElementById('modal'),
    backdrop:document.getElementById('backdrop'),
    okBtn:document.getElementById('okBtn'),
    dictListHost:document.getElementById('dictList')
  };
  if (App.DOM.copyYearEl) App.DOM.copyYearEl.textContent = new Date().getFullYear();

  App.bootstrap = function(){
    // set version label
    if (App.DOM.appVerEl) App.DOM.appVerEl.textContent = 'v' + App.APP_VER;
  };
})();

App.migrateFavoritesToV2 = function(){
  try{
    const st = App.state || (App.state = {});
    if (st.favorites_v2 && typeof st.favorites_v2 === 'object') return; // already migrated

    const old = st.favorites || {};
    const v2 = {};

    const dictKeys = []
      .concat(App.Decks.builtinKeys ? App.Decks.builtinKeys() : [])
      .concat(Object.keys((App.dictRegistry && App.dictRegistry.user) || {}));

    const idToDicts = {};
    dictKeys.forEach(key => {
      const arr = App.Decks.resolveDeckByKey(key) || [];
      arr.forEach(w => {
        (idToDicts[w.id] = idToDicts[w.id] || []).push(key);
      });
    });

    let migrated = 0, skipped = 0;
    Object.keys(old || {}).forEach(idStr => {
      if (!old[idStr]) return;
      const id = +idStr;
      const dicts = idToDicts[id] || [];
      if (dicts.length === 1){
        const k = dicts[0];
        if (!v2[k]) v2[k] = {};
        v2[k][id] = true;
        migrated++;
      } else {
        skipped++;
      }
    });

    st.favorites_v2 = v2;
    st.favorites_legacy = old;
    try { App.saveState && App.saveState(); } catch(e){}
    }catch(e){ console.warn('Favorites v2 migration failed:', e); }
};

App.isFavorite = function(dictKey, wordId){
  try{
    const st = App.state || {};
    const v2 = st.favorites_v2 || {};
    return !!(v2[dictKey] && v2[dictKey][wordId]);
  }catch(e){ return false; }
};

App.toggleFavorite = function(dictKey, wordId){
  try{
    const st = App.state || (App.state = {});
    st.favorites_v2 = st.favorites_v2 || {};
    st.favorites_v2[dictKey] = st.favorites_v2[dictKey] || {};
    st.favorites_v2[dictKey][wordId] = !st.favorites_v2[dictKey][wordId];
    App.saveState && App.saveState();
  }catch(e){}
};

App.clearFavoritesAll = function(){
  try{
    const st = App.state || {};
    st.favorites_v2 = {};
    App.saveState && App.saveState();
  }catch(e){}
};

(function migrateFromWorkingSets(){
  if (window.__ws_migrated__) return;
  window.__ws_migrated__ = true;
  try{
    // 1) Active sets by deck
    const legacySetsRaw = localStorage.getItem('app.setByDeck');
    if (legacySetsRaw){
      try{
        const legacySets = JSON.parse(legacySetsRaw);
        if (legacySets && typeof legacySets==='object'){
          window.App = window.App || {};
          App.Sets = App.Sets || { state:{ activeByDeck:{}, completedByDeck:{} } };
          App.Sets.state = App.Sets.state || { activeByDeck:{}, completedByDeck:{} };
          App.Sets.state.activeByDeck = Object.assign({}, App.Sets.state.activeByDeck, legacySets);
          if (App.Sets._save) App.Sets._save();
        }
      }catch(_){}
      localStorage.removeItem('app.setByDeck');
    }

    // 2) Stars (rare): app.starsByDeck -> flatten into App.state.stars
    const legacyStarsRaw = localStorage.getItem('app.starsByDeck');
    if (legacyStarsRaw){
      try{
        const legacyStarsByDeck = JSON.parse(legacyStarsRaw);
        App.state = App.state || {};
        App.state.stars = App.state.stars || {};
        if (legacyStarsByDeck && typeof legacyStarsByDeck==='object'){
          for (const deckKey of Object.keys(legacyStarsByDeck)){
            const m = legacyStarsByDeck[deckKey]||{};
            for (const wid of Object.keys(m)){
              const v = m[wid]|0;
              App.state.stars[wid] = Math.max(App.state.stars[wid]||0, v|0);
            }
          }
          App.saveState && App.saveState();
        }
      }catch(_){}
      localStorage.removeItem('app.starsByDeck');
    }

    // 3) Mistakes: __mistakes_<deckKey> -> totals.errors
    const keys = Object.keys(localStorage);
    let added = 0;
    keys.forEach(k=>{
      const mm = /^__mistakes_(.+)$/.exec(k);
      if (!mm) return;
      try{
        const arr = JSON.parse(localStorage.getItem(k)||'[]');
        added += Array.isArray(arr) ? arr.length : 0;
      }catch(_){}
      localStorage.removeItem(k);
    });
    if (added>0){
      App.state = App.state || {};
      App.state.totals = App.state.totals || {};
      App.state.totals.errors = (App.state.totals.errors|0) + added;
      App.saveState && App.saveState();
    }
  }catch(_){}
})();

(function(){
  const App = window.App;

  // ───────── базовая логика ─────────
  function starsMax(){ return 5; }
  function unlockThreshold(){ return 3; }

  function weightForWord(w){
    const sMax = starsMax();
    const stars = App.clamp(App.state.stars[w.id]||0, 0, sMax);
    const deficit = (sMax - stars);
    const last = App.state.lastSeen[w.id] || 0;
    const elapsedMin = Math.max(0, (Date.now() - last)/60000);
    const recency = Math.min(elapsedMin/3, 5);
    return Math.max(0.1, 1 + 2*deficit + recency);
  }

  function sampleNextIndexWeighted(deck){
    if (!deck || !deck.length) return 0;
    const forbidden = App.state.lastIndex;
    let total = 0;
    const weights = deck.map((w,idx)=>{
      const base = weightForWord(w);
      const penalty = (idx===forbidden) ? 0.0001 : 1;
      const wgt = base * penalty;
      total += wgt; 
      return wgt;
    });
    let r = Math.random()*total;
    for (let i=0;i<deck.length;i++){ r -= weights[i]; if (r<=0) return i; }
    return Math.floor(Math.random()*deck.length);
  }

  // ───────── поддержка наборов ─────────
  function getSetSize(){
    let raw = 50; // <— по умолчанию 50
    try { raw = Number(App && App.state && App.state.setSize); } catch(e){}
    return (Number.isFinite(raw) && raw >= 2) ? raw : 50;
  }
  function activeKey(){
    return (App && App.dictRegistry && App.dictRegistry.activeKey) || null;
  }
  function resolveDeckByKey(key){
    try{
      return (App && App.Decks && App.Decks.resolveDeckByKey)
        ? (App.Decks.resolveDeckByKey(key) || [])
        : [];
    }catch(e){ return []; }
  }

  function getBatchIndex(deckKey, totalOpt){
    const key = deckKey || activeKey();
    const setSize = getSetSize();

    let total = totalOpt;
    if (!Number.isFinite(total)) {
      const deck = resolveDeckByKey(key);
      total = Math.max(1, Math.ceil(deck.length / setSize));
    }

    App.state = App.state || {};
    App.state.setByDeck = App.state.setByDeck || {};
    let idx = App.state.setByDeck[key] | 0;

    if (idx < 0) idx = 0;
    if (total > 0 && idx >= total) idx = total - 1;
    return idx;
  }

  function setBatchIndex(i, deckKey){
    const key = deckKey || activeKey();
    const setSize = getSetSize();
    const deck = resolveDeckByKey(key);
    const total = Math.max(1, Math.ceil(deck.length / setSize));

    let idx = (i|0);
    if (idx < 0) idx = 0;
    if (idx >= total) idx = total - 1;

    App.state = App.state || {};
    App.state.setByDeck = App.state.setByDeck || {};
    App.state.setByDeck[key] = idx;
    if (typeof App.saveState === 'function') App.saveState();
    return idx;
  }

  function getBatchesMeta(deckKey){
    const key = deckKey || activeKey();
    const deck = resolveDeckByKey(key);
    const setSize = getSetSize();

    const total = Math.max(1, Math.ceil(deck.length / setSize));
    const active = getBatchIndex(key, total);

    const completed = new Array(total).fill(false);
    const stars = (App && App.state && App.state.stars) || {};
    const repeats = starsMax();

    for (let i=0;i<total;i++){
      const start = i * setSize;
      const end = Math.min(deck.length, start + setSize);
      let done = (end > start);
      for (let j=start; j<end; j++){
        const w = deck[j];
        if (!w) { done = false; break; }
        const s = stars[w.id] || 0;
        if (s < repeats) { done = false; break; }
      }
      completed[i] = done;
    }
    return { total, active, completed };
  }

  function getDeckSlice(deckKey){
    const key = deckKey || activeKey();
    const deck = resolveDeckByKey(key);
    const setSize = getSetSize();
    const total = Math.max(1, Math.ceil(deck.length / setSize));
    const idx = getBatchIndex(key, total);
    const start = idx * setSize;
    const end = Math.min(deck.length, start + setSize);
    const slice = deck.slice(start, end);
    return slice.length ? slice : deck;
  }

  
  // ───────── экспорт API тренера ─────────
  App.Trainer = Object.assign({}, App.Trainer || {}, {
    starsMax,
    unlockThreshold,
    sampleNextIndexWeighted,
    // наборы:
    getSetSize,
    getBatchIndex,
    setBatchIndex,
    getBatchesMeta,
    getDeckSlice,
    safeGetDeckSlice: function(deckKey){ try{ return getDeckSlice(deckKey); } catch(e){ return resolveDeckByKey(deckKey||activeKey()); } }
  });

  if (!App.Trainer.sampleNextIndexWeighted && App.Trainer.pickNextIndexWeighted) {
    App.Trainer.sampleNextIndexWeighted = App.Trainer.pickNextIndexWeighted;
  }
})();

(function(){
  var App = window.App || (window.App = {});
  var LS_KEY = 'progress.v2';
  var cache = null;
  function load(){
    if (cache) return cache;
    try{
      var raw = localStorage.getItem(LS_KEY);
      cache = raw ? JSON.parse(raw) : {};
    }catch(e){ cache = {}; }
    return cache;
  }
  var saveScheduled = false;
  function saveNow(){
    try{ localStorage.setItem(LS_KEY, JSON.stringify(cache||{})); }catch(e){}
  }
  function save(){
    if (saveScheduled) return;
    saveScheduled = true;
    setTimeout(function(){ saveScheduled=false; saveNow(); }, 150);
  }
  function bucket(lang, dictKey, setIndex){
    var db = load();
    if (!db[lang]) db[lang] = {};
    if (!db[lang][dictKey]) db[lang][dictKey] = {};
    if (!db[lang][dictKey][setIndex]) db[lang][dictKey][setIndex] = { stars:{}, successes:{}, lastSeen:{} };
    return db[lang][dictKey][setIndex];
  }
  function ctx(){
    var lang = (App.settings && App.settings.lang) || 'ru';
    var dictKey = (App.dictRegistry && App.dictRegistry.activeKey) || (App.Decks && App.Decks.pickDefaultKey && App.Decks.pickDefaultKey()) || 'unknown';
    var setIndex = (App.Sets && App.Sets.getActiveSetIndex && App.Sets.getActiveSetIndex()) || 0;
    return { lang: lang, dictKey: dictKey, setIndex: setIndex, bucket: bucket(lang, dictKey, setIndex) };
  }
  App.Progress = {
    load: load,
    save: save,
    getBucket: function(lang, dictKey, setIndex){ return bucket(lang, dictKey, setIndex); },
    current: ctx,
    getStars: function(wordId){
      var c = ctx(); return (c.bucket.stars && c.bucket.stars[wordId]) || 0;
    },
    setStars: function(wordId, value){
      var c = ctx(); c.bucket.stars[String(wordId)] = value|0; save(); return value|0;
    },
    incSuccess: function(wordId){
      var c = ctx(); c.bucket.successes[String(wordId)] = (c.bucket.successes[String(wordId)]||0)+1; save(); return c.bucket.successes[String(wordId)];
    },
    setLastSeen: function(wordId, ts){
      var c = ctx(); c.bucket.lastSeen[String(wordId)] = ts||Date.now(); save(); return c.bucket.lastSeen[String(wordId)];
    },
    starsForWordIn: function(lang, dictKey, setIndex, wordId){
      var b = bucket(lang, dictKey, setIndex); return (b.stars && b.stars[String(wordId)]) || 0;
    }
  };
})();

(function(){
  var App = window.App || (window.App = {});
  App.Decks = App.Decks || {};
  App.settings = App.settings || { lang: 'ru' };
  App.state = App.state || {};
  App.dictRegistry = App.dictRegistry || { activeKey:null, user:{} };

  function langOfKey(key){
    var m = String(key||'').match(/^([a-z]{2})[_-]/i);
    return m ? m[1].toLowerCase() : null;
  }
  App.Decks.langOfKey = langOfKey;

  function normalizeKey(key){
    if (!key) return null;
    var k = String(key).trim().toLowerCase();
    return k.replace(/\s+/g,'').replace(/_+/g,'_').replace(/-+/g,'-');
  }

  function builtinKeys(){
    var out = [];
    if (window.decks && typeof window.decks === 'object'){
      for (var k in window.decks){
        if (!window.decks.hasOwnProperty(k)) continue;
        var arr = window.decks[k];
        if (Array.isArray(arr) && arr.length) out.push(k);
      }
    }
    var priority = [
      'de_verbs','de_nouns','de_adjectives','de_adverbs',
      'de_pronouns','de_prepositions','de_numbers','de_conjunctions','de_particles'
    ];
    out.sort(function(a,b){
      var ia = priority.indexOf(normalizeKey(a));
      var ib = priority.indexOf(normalizeKey(b));
      if (ia !== -1 && ib !== -1) return ia - ib;
      if (ia !== -1) return -1;
      if (ib !== -1) return 1;
      return String(a).localeCompare(String(b));
    });
    return out;
  }

  function resolveDeckByKey(key){
    if (!key) return [];

    // virtual: mistakes
    if (key === 'mistakes'){
      try {
        return (App.Mistakes && App.Mistakes.deck) ? (App.Mistakes.deck() || []) : [];
      } catch (e) { return []; }
    }

    // virtual: favorites
    if (key === 'fav' || key === 'favorites'){
      try {
        return (App.Favorites && App.Favorites.deck) ? (App.Favorites.deck() || []) : [];
      } catch (e) { return []; }
    }

    // user-defined
    if (key.indexOf('user-') === 0){
      var u = App.dictRegistry.user || {};
      var d = u[key] && u[key].words;
      return Array.isArray(d) ? d : [];
    }

    // builtin
    if (window.decks && Array.isArray(window.decks[key])) return window.decks[key];

    var canon = normalizeKey(key);
    if (canon && canon !== key && window.decks && Array.isArray(window.decks[canon])) return window.decks[canon];

    return [];
  }

  function resolveNameByKey(key){
    var t = (typeof App.i18n === 'function') ? App.i18n() : null;
    if (key === 'mistakes') return (t && t.mistakesName) ? t.mistakesName : 'Мои ошибки';
    if (key === 'fav' || key === 'favorites') return (App.settings.lang === 'ru') ? 'Избранное' : 'Обране';

    var m = String(key||'').match(/^([a-z]{2})_([a-z]+)$/i);
    var uiRu = (App.settings.lang === 'ru');
    var POS_RU = {
      verbs:'Глаголы', nouns:'Существительные', adjectives:'Прилагательные',
      adverbs:'Наречия', pronouns:'Местоимения', prepositions:'Предлоги',
      conjunctions:'Союзы', particles:'Частицы', numbers:'Числительные'
    };
    var POS_UK = {
      verbs:'Дієслова', nouns:'Іменники', adjectives:'Прикметники',
      adverbs:'Прислівники', pronouns:'Займенники', prepositions:'Прийменники',
      conjunctions:'Сполучники', particles:'Частки', numbers:'Числівники'
    };
    if (m) {
      var pos = m[2].toLowerCase();
      var POS = uiRu ? POS_RU : POS_UK;
      if (POS[pos]) return POS[pos];
    }
    return uiRu ? 'Словарь' : 'Словник';
  }

  function flagForKey(key){
    if (key === 'fav' || key === 'favorites') return '♥';
    var lg = langOfKey(key) || '';
    var MAP = { en:'🇬🇧', de:'🇩🇪', fr:'🇫🇷', es:'🇪🇸', it:'🇮🇹', pl:'🇵🇱', sr:'🇷🇸', ru:'🇷🇺', uk:'🇺🇦', tr:'🇹🇷' };
    return MAP[lg] || '🌐';
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, function(c){
      return { '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;' }[c];
    });
  }
  function openPreview(words, title){
    var t = (typeof App.i18n === 'function') ? App.i18n() : { pos_misc:'Слова' };
    var tr = (App.settings.lang === 'ru') ? 'ru' : 'uk';
    var rows = (words||[]).map(function(w){ return '<tr><td>'+escapeHtml(w.word||'')+'</td><td>'+escapeHtml(w[tr]||'')+'</td></tr>'; }).join('');
    var html = '<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>'+escapeHtml(title||'')+'</title>'+
    '<style>body{font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:16px}table{border-collapse:collapse;width:100%}th,td{border:1px solid #e5e7eb;padding:8px 10px;text-align:left}thead th{background:#f8fafc}</style>'+
    '</head><body><h3>'+escapeHtml(title||'')+'</h3><table><thead><tr><th>'+(t.pos_misc||'Слова')+'</th><th>'+((tr==='ru')?'Перевод':'Переклад')+'</th></tr></thead><tbody>'+rows+'</tbody></table></body></html>';
    var blob = new Blob([html], {type:'text/html;charset=utf-8;'});
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a'); a.href = url; a.target = '_blank'; a.rel='noopener'; a.click();
    setTimeout(function(){ URL.revokeObjectURL(url); }, 60000);
  }

  function pickDefaultKey(){
    var fav = resolveDeckByKey('fav');
    if (fav && fav.length >= 4) return 'fav';
    var built = builtinKeys();
    for (var i=0;i<built.length;i++){
      var arr = resolveDeckByKey(built[i]);
      if (arr && arr.length >= 4) return built[i];
    }
    var users = Object.keys(App.dictRegistry.user || {});
    for (var j=0;j<users.length;j++){
      var d = resolveDeckByKey(users[j]);
      if (d && d.length >= 4) return users[j];
    }
    return built[0] || (users.length?users[0]:null);
  }

  App.Decks = {
    langOfKey: langOfKey,
    builtinKeys: builtinKeys,
    resolveDeckByKey: resolveDeckByKey,
    resolveNameByKey: resolveNameByKey,
    flagForKey: flagForKey,
    openPreview: openPreview,
    pickDefaultKey: pickDefaultKey
  };
})();

(function(){
  const App = window.App || (window.App = {});
  

function isCurrentSetReady(){
  try{
    const deckKey = (App && App.state && App.state.activeDeck) || (App && App.Decks && App.Decks.activeKey && App.Decks.activeKey());
    const deck = (App && App.Decks && App.Decks.byKey) ? (App.Decks.byKey(deckKey) || []) : (App && App.deck ? App.deck : []);
    if (!deck || !deck.length) return false;
    const b = (App && App.Sets && App.Sets.activeBounds) ? App.Sets.activeBounds(deck.length) : null;
    if (!b) return false;
    const sMax = (App.Trainer && App.Trainer.starsMax) ? App.Trainer.starsMax() : 5;
    const ok = (App.Trainer && App.Trainer.unlockThreshold) ? App.Trainer.unlockThreshold() : 3;
    const stars = (App.state && App.state.stars) || {};
    for (let i=b.start;i<b.end;i++){
      const w = deck[i]; if (!w) continue;
      const sc = Math.max(0, Math.min(sMax, stars[w.id]||0));
      if (sc < ok) return false;
    }
    return true;
  }catch(_){ return false; }
}

App.Sets = App.Sets || {};
  const S = App.Sets;
  const LS_KEY = 'sets.progress.v1';
  const SET_SIZE = 50; // размер набора по умолчанию

  S.SET_SIZE = SET_SIZE;
  // per-dict state
  S.state = { activeByDeck: {}, completedByDeck: {} };

  function deckKey(){ return (App.dictRegistry && App.dictRegistry.activeKey) || 'default'; }
  function getDeck(){ try{ return (App.Decks && App.Decks.resolveDeckByKey(App.dictRegistry.activeKey)) || []; }catch(_){ return []; } }
  function setCount(len){ return Math.max(1, Math.ceil(len / SET_SIZE)); }
  function boundsForSet(idx, len){
    const start = idx * SET_SIZE;
    const end = Math.min(len, start + SET_SIZE);
    return { start, end };
  }

  function loadLS(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (raw){
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed==='object'){
          S.state.activeByDeck = parsed.activeByDeck || {};
          S.state.completedByDeck = parsed.completedByDeck || {};
        }
      }
    }catch(_){}
  }
  function saveLS(){
    try{ localStorage.setItem(LS_KEY, JSON.stringify(S.state)); }catch(_){}
  }

  // API
  S.setTotalCount = function(){ return setCount(getDeck().length); };
  S.activeBounds = function(){
    const len = getDeck().length;
    const idx = S.getActiveSetIndex();
    return boundsForSet(idx, len);
  };
  S.getActiveSetIndex = function(){
    const k = deckKey();
    let i = S.state.activeByDeck[k];
    if (!Number.isFinite(i) || i < 0) i = 0;
    const cnt = setCount(getDeck().length);
    if (i >= cnt) i = cnt - 1;
    if (S.state.activeByDeck[k] !== i){ S.state.activeByDeck[k] = i; saveLS(); }
    return i;
  };
  S.setActiveSetIndex = function(i){
    const k = deckKey();
    const cnt = setCount(getDeck().length);
    const clamped = Math.max(0, Math.min(cnt-1, i|0));
    S.state.activeByDeck[k] = clamped;
    saveLS();
  
    
    // Sync trainer batch index
    try { if (App.Trainer && typeof App.Trainer.setBatchIndex==='function') App.Trainer.setBatchIndex(clamped, k);
  if (App.switchToSetImmediate) App.switchToSetImmediate(); } catch(e){}
    // UI refresh & event
    try { if (App.renderSetsBar) App.renderSetsBar(); } catch(e){}
    try { if (typeof renderSetStats==='function') renderSetStats(); else if (App.renderSetStats) App.renderSetStats(); } catch(e){}
    try { document.dispatchEvent(new CustomEvent('sets:active-changed',{detail:{key:k,index:clamped}})); } catch(e){}

  };
  S.isSetDone = function(i){
    const k = deckKey();
    const map = S.state.completedByDeck[k] || {};
    return !!map[i];
  };
  S.markSetDone = function(i){
    const k = deckKey();
    if (!S.state.completedByDeck[k]) S.state.completedByDeck[k] = {};
    S.state.completedByDeck[k][i] = true;
    saveLS();
  };

  // Критерий завершения набора: все слова в границах набора имеют звёзды >= starsMax
  function isActiveSetLearned(){
    try{
      const deck = getDeck();
      const b = S.activeBounds();
      const sMax = (App.Trainer && App.Trainer.starsMax && App.Trainer.starsMax()) || 6;
      const stars = (App.state && App.state.stars) || {};
      for (let i=b.start;i<b.end;i++){
        const w = deck[i]; if (!w) continue;
        const sc = Math.max(0, Math.min(sMax, stars[w.id]||0));
        if (sc < sMax) return false;
      }
      return (b.end - b.start) > 0;
    }catch(_){ return false; }
  }

  // Проверка завершения и автопереход
  S.checkCompletionAndAdvance = function(){
    const total = S.setTotalCount();
    if (total <= 0) return;
    if (!isActiveSetLearned()) return;

    const cur = S.getActiveSetIndex();
    S.markSetDone(cur);
    const next = (cur + 1 < total) ? (cur + 1) : 0; // цикл к первому
    S.setActiveSetIndex(next);

    // Переставляем индекс слова в начало нового набора
    if (typeof App.switchToSetImmediate === 'function') {
      App.switchToSetImmediate();
    
    try { if (App.renderSetsBar) App.renderSetsBar(); } catch(e){}
    try { document.dispatchEvent(new CustomEvent('sets:active-changed')); } catch(e){}
} else {
      // безопасный фолбэк
      try{
        const b = S.activeBounds();
        if (App.state) App.state.index = b.start|0;
      }catch(_){}
    }
  };

  loadLS();
  // экспорт служебного
  S._save = saveLS;
})();

(function(){
  const App = window.App || (window.App = {});
  const M = App.Mistakes || (App.Mistakes = {});

  const LS = 'mistakes.v4';
  const toInt = (x, d)=>{ x = Number(x); return Number.isFinite(x) ? x : (d||0); };

  function load(){ try{ return JSON.parse(localStorage.getItem(LS)||'{}'); }catch(e){ return {}; } }
  function save(s){ try{ localStorage.setItem(LS, JSON.stringify(s)); }catch(e){} }

  function uiLang(){ return (App.settings && App.settings.lang === 'uk') ? 'uk' : 'ru'; }
  function langOfKey(k){ try{ const m = String(k||'').match(/^([a-z]{2})_/i); return m?m[1].toLowerCase():null; }catch(e){ return null; } }
  function activeDictLang(){
    if (App.settings && App.settings.dictsLangFilter) return App.settings.dictsLangFilter;
    const key = (App.dictRegistry && App.dictRegistry.activeKey) || null;
    return langOfKey(key) || 'de';
  }
  function ensureBucket(db, ul, dl){
    if (!db[ul]) db[ul] = {};
    if (!db[ul][dl]) db[ul][dl] = { items:{}, stars:{}, sources:{} };
    return db[ul][dl];
  }

  // Public: add
  M.add = function(id, word, sourceKey){
    if (!id) return;
    id = String(id);
    if (!sourceKey){
      if (word && (word._mistakeSourceKey || word._favoriteSourceKey)) sourceKey = word._mistakeSourceKey || word._favoriteSourceKey;
      if (!sourceKey){
        const ak = (App.dictRegistry && App.dictRegistry.activeKey) || null;
        if (ak && ak !== 'mistakes') sourceKey = ak;
      }
    }
    if (!sourceKey) return;
    const ul = uiLang(), dl = langOfKey(sourceKey) || activeDictLang();
    const db = load(), b = ensureBucket(db, ul, dl);
    if (!b.items[sourceKey]) b.items[sourceKey] = {};
    b.items[sourceKey][id] = true;
    b.sources[id] = sourceKey;
    save(db);
  };

  // Public: sourceKey
  M.sourceKeyFor = function(id){
    const db = load(); const ul = uiLang(), dl = activeDictLang();
    const b = ensureBucket(db, ul, dl);
    return (b.sources||{})[String(id)] || null;
  };
  M.sourceKeyInActive = M.sourceKeyFor;

  // Progress (independent from App.state.stars)
  function starsBucket(db){
    const b = ensureBucket(db, uiLang(), activeDictLang());
    return b.stars || (b.stars = {});
  }
  M.getStars = function(sourceKey, id){
    const db = load(); const sb = starsBucket(db);
    const sk = String(sourceKey||''); const wid = String(id||'');
    return toInt((sb[sk]||{})[wid], 0);
  };
  M.setStars = function(sourceKey, id, val){
    const db = load(); const sb = starsBucket(db);
    const sk = String(sourceKey||''); const wid = String(id||'');
    if (!sb[sk]) sb[sk] = {};
    sb[sk][wid] = toInt(val, 0);
    save(db);
  };

  // Deck/list/count for ACTIVE scope (uiLang+dictLang)
  M.deck = function(){
    const db = load(); const ul = uiLang(); const dl = activeDictLang();
    const b = ensureBucket(db, ul, dl);
    const out = [];
    Object.keys(b.items||{}).forEach(sk=>{
      const ids = b.items[sk] || {};
      const deck = (App.Decks && App.Decks.resolveDeckByKey) ? (App.Decks.resolveDeckByKey(sk)||[]) : [];
      if (!deck.length) return;
      const map = new Map(deck.map(w=>[String(w.id), w]));
      Object.keys(ids).forEach(id=>{
        const w = map.get(String(id));
        if (w){ if (!w._mistakeSourceKey) w._mistakeSourceKey = sk; out.push(w); }
      });
    });
    return out;
  };
  M.list = function(){ return M.deck(); };
  M.count = function(){
    const db = load(); const ul = uiLang(); const dl = activeDictLang();
    const b = ensureBucket(db, ul, dl);
    let n = 0; Object.keys(b.items||{}).forEach(sk=>{ n += Object.keys(b.items[sk]||{}).length; });
    return n;
  };

  // Clear only active scope
  M.clearActive = function(){
    const db = load(); const ul = uiLang(); const dl = activeDictLang();
    db[ul] && (db[ul][dl] = { items:{}, stars:{}, sources:{} }); save(db);
  };

  M.onShow = function(id){}; // reserved
})();

(function(){
  var App = window.App || (window.App = {});
  var PROG_KEY = 'favorites.progress.v1';

  function uiLang(){ return (App.settings && App.settings.lang) || 'ru'; }
  function dictFilterLang(){
    return (App.settings && App.settings.dictsLangFilter) || null;
  }
  function now(){ return Date.now ? Date.now() : (+new Date()); }

  function loadProg(){ try{ var raw = localStorage.getItem(PROG_KEY); return raw? JSON.parse(raw): {}; }catch(e){ return {}; } }
  function saveProg(db){ try{ localStorage.setItem(PROG_KEY, JSON.stringify(db)); }catch(e){} }
  function progKey(dictKey, id){ return dictKey + '#' + String(id); }
  function starsMax(){ try{ return App.Trainer.starsMax(); }catch(e){ return 5; } }

  function pget(ui, dictKey, id){ var db=loadProg(); var L=db[ui]||{}; var k=progKey(dictKey,id); return (L[k] && L[k].stars)|0 || 0; }
  function pset(ui, dictKey, id, val){
    var db=loadProg(); if(!db[ui]) db[ui] = {};
    var k=progKey(dictKey,id); var cur=db[ui][k] || {stars:0, ts:0};
    var mx=starsMax(); cur.stars = Math.max(0, Math.min(val|0, mx)); cur.ts = Date.now ? Date.now() : (+new Date());
    db[ui][k]=cur; saveProg(db); return cur.stars;
  }
  function pinc(ui, dictKey, id, d){ return pset(ui, dictKey, id, pget(ui, dictKey, id) + (d|0)); }
  function pled(ui, dictKey, id){ return pget(ui, dictKey, id) >= starsMax(); }

  function keyLang(key){
    try{ return (App.Decks && App.Decks.langOfKey) ? (App.Decks.langOfKey(key) || null) : null; }catch(e){ return null; }
  }
  function resolveDeck(key){
    try{ return (App.Decks && App.Decks.resolveDeckByKey) ? (App.Decks.resolveDeckByKey(key) || []) : []; }catch(e){ return []; }
  }

  function aliveWord(dictKey, id){
    var deck = resolveDeck(dictKey); if (!deck || !deck.length) return null;
    id = String(id);
    for (var i=0;i<deck.length;i++){ if (String(deck[i].id) === id) return deck[i]; }
    return null;
  }

  App.Favorites = {
    progress: {
      getStars: function(dictKey,id){ return pget(uiLang(), dictKey, id); },
      setStars: function(dictKey,id,val){ return pset(uiLang(), dictKey, id, val); },
      incStar:  function(dictKey,id,delta){ return pinc(uiLang(), dictKey, id, delta||1); },
      reset:    function(dictKey,id){ return pset(uiLang(), dictKey, id, 0); },
      isLearned:function(dictKey,id){ return pled(uiLang(), dictKey, id); },
      clearAllForUi: function(){
        var ui = uiLang(); var db=loadProg(); if (db[ui]) { db[ui] = {}; saveProg(db); }
      }
    },

    list: function(){
      try{
        App.migrateFavoritesToV2 && App.migrateFavoritesToV2();
        var st = App.state || {}; var v2 = st.favorites_v2 || {};
        var flg = dictFilterLang();
        var out = [];
        Object.keys(v2).forEach(function(dictKey){
          if (flg && keyLang(dictKey) !== flg) return;
          var map = v2[dictKey] || {};
          Object.keys(map).forEach(function(id){
            if (!map[id]) return;
            var w = aliveWord(dictKey, id);
            if (!w) return;
            out.push({ id: String(id), dictKey: dictKey, ts: 0 });
          });
        });
        return out;
      }catch(e){ return []; }
    },

    count: function(){
      var arr = App.Favorites.list() || [];
      return arr.length;
    },

    deck: function(){
      var arr = App.Favorites.list() || [], out=[];
      for (var i=0;i<arr.length;i++){
        var e = arr[i]; var w = aliveWord(e.dictKey, e.id);
        if (!w) continue;
        var ww = Object.assign({}, w);
        ww._favoriteSourceKey = e.dictKey;
        out.push(ww);
      }
      return out;
    },

    clearActive: function(){
      try{
        if (App.clearFavoritesAll) App.clearFavoritesAll();
        App.Favorites.progress.clearAllForUi();
      }catch(e){}
    }
  };
})();

(function(){
  const App = window.App || (window.App = {});

  function _langOfKey(k){
    try{
      const m = String(k||'').match(/^([a-z]{2})_/i);
      return m ? m[1].toLowerCase() : null;
    }catch(e){ return null; }
  }

  function _activeDictLang(){
    if (App.settings && App.settings.dictsLangFilter) return App.settings.dictsLangFilter;
    const key = (App.dictRegistry && App.dictRegistry.activeKey) || null;
    return _langOfKey(key) || 'de';
  }

  App.clearFavoritesForLang = function(dictLang){
    try{
      const lang = dictLang || _activeDictLang();
      const st = (App.state && App.state.favorites_v2) ? App.state.favorites_v2 : null;
      if (!st) return;
      Object.keys(st).forEach(function(sourceKey){
        if (_langOfKey(sourceKey) === lang) delete st[sourceKey];
      });
      App.saveState && App.saveState();
    }catch(e){}
  };

  // Keep global clear as a compatibility fallback
  App.clearFavoritesAll = App.clearFavoritesAll || function(){
    try { if (App.state) App.state.favorites_v2 = {}; App.saveState && App.saveState(); } catch(e){}
  };
})();

(function(){
  const App=window.App, D=App.DOM;

  function getActiveDeck(){ if (App.Trainer && typeof App.Trainer.safeGetDeckSlice==='function') return App.Trainer.safeGetDeckSlice(App.dictRegistry.activeKey)||[]; return App.Decks.resolveDeckByKey(App.dictRegistry.activeKey)||[]; }
  function current(){
    const deck=getActiveDeck();
    if(!deck.length) return {id:-1,word:'',uk:'',ru:''};
    if (App.state.index<0 || App.state.index>=deck.length) App.state.index=0;
    return deck[App.state.index];
  }
  function decideModeForWord(w){ const succ=App.state.successes[w.id]||0; return (succ>=App.Trainer.unlockThreshold())?(Math.random()<0.5):false; }

  function renderStars(){
    const w=current(); const score=App.clamp(App.state.stars[w.id]||0,0,App.Trainer.starsMax());
    const host=D.starsEl; if(!host) return; host.innerHTML='';
    for(let i=0;i<App.Trainer.starsMax();i++){ const s=document.createElement('span'); s.className='starIcon'+(i<score?' filled':''); s.textContent='★'; host.appendChild(s); }
  }
  function updateStats(){
    const t=App.i18n(); const total=getActiveDeck().length;
    const learned=Object.values(App.state.stars).reduce((a,v)=>a+((v||0)>=App.Trainer.starsMax()?1:0),0);
    const errors=App.state.totals.errors|0;
    if(D.statsBar) D.statsBar.textContent=`${t.totalWords}: ${total} / ${t.learned}: ${learned} / ${t.errors}: ${errors}`;
  }

  function drawOptions(correct,pool){
    const distractors=App.shuffle(pool).slice(0,3);
    const variants=App.shuffle([correct,...distractors]);
    variants.forEach(v=>{ const b=document.createElement('button'); b.className='optionBtn'; b.textContent=v; if(v===correct) b.dataset.correct='1'; b.addEventListener('click',()=>onChoice(b,v===correct)); D.optionsRow.appendChild(b); });
  }
  function addIDontKnowButton(){
    const t=App.i18n(); const wrap=document.createElement('div'); wrap.className='idkWrapper';
    const b=document.createElement('button'); b.className='ghost'; b.textContent=t.iDontKnow; b.addEventListener('click',onIDontKnow);
    wrap.appendChild(b); D.optionsRow.appendChild(wrap);
  }

  function renderCard(force=false){
    if(document.activeElement&&document.activeElement.blur) try{document.activeElement.blur();}catch(e){}
    const deck=getActiveDeck();
    if(!deck.length){ if(D.wordEl) D.wordEl.textContent='—'; if(D.hintEl) D.hintEl.textContent='—'; if(D.optionsRow) D.optionsRow.innerHTML=''; renderStars(); updateStats(); return; }

    if (force || App.state.index===App.state.lastIndex) App.state.index = App.Trainer.sampleNextIndexWeighted(deck);
    const w=current();
    if (App.state.lastShownWordId!==w.id){ App.state.totals.shown+=1; App.state.lastShownWordId=w.id; App.state.lastSeen[w.id]=Date.now(); App.saveState(); }

    const t=App.i18n(); const isReverse=decideModeForWord(w);
    renderStars(); D.optionsRow.innerHTML='';
    if(!isReverse){
      if(D.wordEl) D.wordEl.textContent=w.word;
      const correct=(App.settings.lang==='ru')?w.ru:w.uk;
      const pool=deck.filter(x=>x.id!==w.id).map(x=>(App.settings.lang==='ru'?x.ru:x.uk));
      drawOptions(correct,pool);
    }else{
      if(D.wordEl) D.wordEl.textContent=(App.settings.lang==='ru')?w.ru:w.uk;
      const correct=w.word; const pool=deck.filter(x=>x.id!==w.id).map(x=>x.word);
      drawOptions(correct,pool);
    }
    if(D.hintEl) D.hintEl.textContent=t.choose;

    if(D.favBtn){
      const isFavDeck=(App.dictRegistry.activeKey==='fav');
      D.favBtn.textContent=App.state.favorites[w.id]?'♥':'♡';
      D.favBtn.disabled=isFavDeck;
    }
    addIDontKnowButton(); updateStats();
  }

  function onChoice(btn,correct){
    const w=current(); const cur=App.clamp(App.state.stars[w.id]||0,0,App.Trainer.starsMax());
    if(correct){
      btn.classList.add('correct'); D.optionsRow.querySelectorAll('button.optionBtn').forEach(b=>b.disabled=true);
      App.state.stars[w.id]=App.clamp(cur+1,0,App.Trainer.starsMax()); App.state.successes[w.id]=(App.state.successes[w.id]||0)+1; App.saveState(); try{ App.Sets && App.Sets.checkCompletionAndAdvance && App.Sets.checkCompletionAndAdvance(); }catch(e){} renderStars(); updateStats(); setTimeout(nextWord,500);
    }else{
      btn.classList.add('wrong'); btn.disabled=true; App.state.stars[w.id]=App.clamp(cur-1,0,App.Trainer.starsMax()); App.state.totals.errors+=1; App.saveState(); renderStars(); updateStats();
    }
  }
  function onIDontKnow(){ const w=current(); const c=D.optionsRow.querySelector('button.optionBtn[data-correct="1"]'); if(c) c.classList.add('correct'); D.optionsRow.querySelectorAll('button.optionBtn').forEach(b=>b.disabled=true); const cur=App.clamp(App.state.stars[w.id]||0,0,App.Trainer.starsMax()); App.state.stars[w.id]=App.clamp(cur-1,0,App.Trainer.starsMax()); App.saveState(); renderStars(); updateStats(); setTimeout(nextWord,700); }
  function nextWord(){ App.state.lastIndex=App.state.index; const deck=getActiveDeck(); App.state.index=App.Trainer.sampleNextIndexWeighted(deck); renderCard(true); }
  function toggleFav(){ const w=current(); App.state.favorites[w.id]=!App.state.favorites[w.id]; App.saveState(); if(D.favBtn){ D.favBtn.textContent=App.state.favorites[w.id]?'♥':'♡'; D.favBtn.style.transform='scale(1.2)'; setTimeout(()=>{D.favBtn.style.transform='scale(1)';},140);} renderDictList(); }

  function canShowFav(){ const fav=App.Decks.resolveDeckByKey('fav'); return (fav&&fav.length>=4); }
  function makeDictRow(key){
    const words=App.Decks.resolveDeckByKey(key)||[];
    const row=document.createElement('div'); row.className='dictRow'+(key===App.dictRegistry.activeKey?' active':''); row.dataset.key=key;
    const flag=document.createElement('div'); flag.className='dictFlag'; flag.textContent=App.Decks.flagForKey(key,words);
    const name=document.createElement('div'); name.className='dictName'; name.textContent=App.Decks.resolveNameByKey(key); name.title=name.textContent;
    const actions=document.createElement('div'); actions.className='dictActions';
    const prevBtn=document.createElement('button'); prevBtn.className='iconOnly'; prevBtn.title=App.i18n().ttPreview; prevBtn.textContent='👁️'; prevBtn.addEventListener('click',(e)=>{e.stopPropagation(); App.Decks.openPreview(words,name.textContent);});
    actions.appendChild(prevBtn);
    // --- КНОПКА УДАЛЕНИЯ ИЗБРАННОГО (только для fav) ---
if (key === 'fav' || key === 'favorites') {
  const delBtn = document.createElement('button');
  delBtn.className = 'iconOnly';
  delBtn.title = (App.settings.lang === 'ru')
    ? 'Очистить «Избранное»'
    : 'Очистити «Обране»';
  delBtn.textContent = '🗑️';
  delBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const msg = (App.settings.lang === 'ru')
      ? 'Очистить «Избранное»? Это действие нельзя отменить.'
      : 'Очистити «Обране»? Дію не можна скасувати.';
    if (!confirm(msg)) return;

    // очистка избранного
    App.state.favorites = {};
    App.saveState();

    // переключение на "Существительные"
    const nounKey = Object.keys(App.Decks.builtinKeys ? App.Decks.builtinKeys() : [])
      .find(k => App.Decks.resolveNameByKey(k) === (App.settings.lang === 'ru' ? 'Существительные' : 'Іменники'));

    if (nounKey) {
      App.dictRegistry.activeKey = nounKey;
    } else {
      App.dictRegistry.activeKey = App.Decks.pickDefaultKey();
    }
    App.saveDictRegistry();

    renderDictList();
    renderCard(true);
    updateStats();
  });
  actions.appendChild(delBtn);
}

    row.appendChild(flag); row.appendChild(name); row.appendChild(actions);
    row.addEventListener('click',()=>{ App.dictRegistry.activeKey=key; App.saveDictRegistry(); App.state.index=0; App.state.lastIndex=-1; renderDictList(); renderCard(true); updateStats(); });
    return row;
  }
  function renderDictList(){
    const host=D.dictListHost; if(!host) return; host.innerHTML='';
    const filter=(App.settings && App.settings.dictsLangFilter)||'all';
    const accept = (k)=>{ if(!k) return false; if(k==='fav'||k==='mistakes') return true; if(filter==='all') return true; return __keyLang(k)===filter; };
    if (canShowFav()) host.appendChild(makeDictRow('fav'));
    for (const k of App.Decks.builtinKeys()) { if (accept(k)) host.appendChild(makeDictRow(k)); }
    for (const k of Object.keys(App.dictRegistry.user||{})) { if (accept(k)) host.appendChild(makeDictRow(k)); }
  }

  function applyLang(){ const t=App.i18n(); if (D.titleEl&&D.titleEl.firstChild) D.titleEl.firstChild.textContent=t.appTitle+' '; if (D.appVerEl) D.appVerEl.textContent='v'+App.APP_VER; if (D.taglineEl) D.taglineEl.textContent=t.tagline; if (D.dictsBtn) D.dictsBtn.title = t.dictsHeader; if (D.modalTitleEl) D.modalTitleEl.textContent = t.dictsHeader || t.modalTitle || 'Словари'; renderDictList(); updateStats(); }

  function openModal(){ if(D.modal) D.modal.classList.remove('hidden'); }
  function closeModal(){ if(D.modal) D.modal.classList.add('hidden'); }

  function bindHeaderButtons(){
    if (D.langToggleBtn){
      D.langToggleBtn.addEventListener('click',()=>{
        App.settings.lang = (App.settings.lang==='ru') ? 'uk' : 'ru';
        D.langToggleBtn.textContent = (App.settings.lang==='ru') ? '🇷🇺' : '🇺🇦';
        App.saveSettings(App.settings); applyLang(); App.applyTheme();
        renderCard(true);
      });
    }
    if (D.themeToggleBtn){
      const updateIcon=()=>{ const mode=document.documentElement.getAttribute('data-theme'); D.themeToggleBtn.textContent = (mode==='dark')?'🌙':'🌞'; };
      D.themeToggleBtn.addEventListener('click',()=>{
        const cur=document.documentElement.getAttribute('data-theme')||'light';
        const next = (cur==='dark')?'light':'dark';
        App.settings.theme=next; App.saveSettings(App.settings); App.applyTheme(); updateIcon();
      });
      updateIcon();
    }
    if (D.dictsBtn){
      D.dictsBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); openModal(); });
    }
    if (D.okBtn){ D.okBtn.addEventListener('click',()=>{ closeModal(); }); }
    if (D.backdrop){ D.backdrop.addEventListener('click',()=>{ closeModal(); }); }
    if (D.favBtn){ D.favBtn.addEventListener('click', toggleFav); }
  }

  const _origBootstrap = App.bootstrap;
  App.bootstrap = function(){
    _origBootstrap();
    if (!App.dictRegistry.activeKey){ App.dictRegistry.activeKey = App.Decks.pickDefaultKey(); App.saveDictRegistry(); }
    applyLang(); App.applyTheme(); App.scheduleThemeTick();
    bindHeaderButtons();
    renderCard(true);
  };

  document.addEventListener('DOMContentLoaded', App.bootstrap);
})();

(function () {
  const App = window.App || (window.App = {});
  const D = App.DOM || (App.DOM = {});

  // ─ helpers ─
  function keyLang(key){
    const m = String(key||'').match(/^([a-z]{2})_/i);
    return m ? m[1].toLowerCase() : 'xx';
  }
  function langOfKey(k){ try{ const m = String(k||'').match(/^([a-z]{2})_/i); return m?m[1].toLowerCase():null; }catch(e){ return null; } }
  function isEndlessDict(key){ return key === 'mistakes' || key === 'fav' || key === 'favorites'; }

  // ─ title + set stats ─
  function renderDictTitle(){
    try{
      const el = document.getElementById('dictActiveTitle');
      if (!el) return;
      const key = (App.dictRegistry && App.dictRegistry.activeKey) || null;
      const name = (App.Decks && App.Decks.resolveNameByKey) ? App.Decks.resolveNameByKey(key) : (key||'');
      el.textContent = name || '';
    }catch(_){}
  }

  function renderSetStats(){
    try{
      const host = document.getElementById('setStats');
      if (!host || !App.Sets) return;
      const b = App.Sets.activeBounds ? App.Sets.activeBounds() : {start:0,end:0};
      const key = (App.dictRegistry && App.dictRegistry.activeKey) || null;
      const deck = (App.Decks && App.Decks.resolveDeckByKey) ? (App.Decks.resolveDeckByKey(key)||[]) : [];
      const sMax = (App.Trainer && App.Trainer.starsMax) ? App.Trainer.starsMax() : 6;
      const total = Math.max(0, (b.end - b.start));
      let learned = 0;

      if (key === 'mistakes' && App.Mistakes && App.Mistakes.getStars){
        for (let i=b.start;i<b.end;i++){
          const w = deck[i]; if(!w) continue;
          const sk = w._mistakeSourceKey || (App.Mistakes.sourceKeyFor && App.Mistakes.sourceKeyFor(w.id));
          const sc = App.Mistakes.getStars(sk, w.id);
          if (sc >= sMax) learned++;
        }
      } else {
        const stars = (App.state && App.state.stars) || {};
        for (let i=b.start;i<b.end;i++){
          const w = deck[i]; if(!w) continue;
          if ((stars[w.id]||0) >= sMax) learned++;
        }
      }

      const t = (typeof App.i18n === 'function') ? App.i18n() : { badgeSetWords:'Слов в наборе', badgeLearned:'Выучено' };
      host.textContent = (t.badgeSetWords||'Слов в наборе') + ': ' + String(total) + ' / ' + (t.badgeLearned||'Выучено') + ': ' + String(learned);
    }catch(_){}
  }

  function _categoryRank(key){
    try{
      const k = String(key||'').toLowerCase().replace(/\s+/g,'');
      const suf = k.replace(/^[a-z]{2}_/,'');
      const order = { verbs:0, nouns:1, adjectives:2, adverbs:3, pronouns:4, prepositions:5, numbers:6, conjunctions:7, particles:8 };
      return (suf in order) ? order[suf] : 999;
    } catch(e){ return 999; }
  }
  function _sortKeysByCategory(keys){
    return (keys||[]).slice().sort((a,b)=>{
      const ra=_categoryRank(a), rb=_categoryRank(b);
      if (ra!==rb) return ra-rb;
      return String(a).localeCompare(String(b));
    });
  }

  function getActiveDeck() {
    if (App.Trainer && typeof App.Trainer.safeGetDeckSlice === 'function') {
      return App.Trainer.safeGetDeckSlice(App.dictRegistry.activeKey) || [];
    }
    if (App.Trainer && typeof App.Trainer.getDeckSlice === 'function') {
      const slice = App.Trainer.getDeckSlice(App.dictRegistry.activeKey) || [];
      if (slice && slice.length) return slice;
    }
    return App.Decks.resolveDeckByKey(App.dictRegistry.activeKey) || [];
  }

  function current() {
    const deck = getActiveDeck();
    if (!deck.length) return { id: -1, word: '', uk: '', ru: '' };
    if (App.state.index < 0 || App.state.index >= deck.length) App.state.index = 0;
    return deck[App.state.index];
  }

  function decideModeForWord(w) {
    const succ = App.state.successes[w.id] || 0;
    let reverse = (succ >= App.Trainer.unlockThreshold()) ? (Math.random() < 0.5) : false;
    try {
      if (App.Penalties) {
        const p = App.Penalties.reverseProbFor(w.id);
        if (Math.random() < p) reverse = true;
      }
    } catch (e) {}
    return reverse;
  }

  // ─ variants (with dedup) ─
  function drawOptions(correct, pool) {
    // Build a unique set of distractors by final button text
    const uniq = [];
    const seen = new Set();
    for (let i=0;i<pool.length;i++){
      const v = pool[i];
      const s = String(v||'').trim();
      if (!s || s === correct) continue;
      if (!seen.has(s)){ seen.add(s); uniq.push(s); }
      if (uniq.length >= 12) break;
    }
    // pad to 3 unique distractors later using fallback in caller
    const need = Math.max(0, 3 - uniq.length);
    const distractors = App.shuffle(uniq).slice(0, 3);
    const variants = App.shuffle([correct, ...distractors]);
    variants.forEach(v => {
      const b = document.createElement('button');
      b.className = 'optionBtn';
      b.textContent = v;
      if (v === correct) b.dataset.correct = '1';
      b.addEventListener('click', () => onChoice(b, v === correct));
      D.optionsRow.appendChild(b);
    });
  }

  function addIDontKnowButton() {
    if (!D || !D.optionsRow) return;
    const t = (typeof App.i18n === 'function') ? App.i18n() : { iDontKnow: 'Не знаю' };
    const wrap = document.createElement('div');
    wrap.className = 'idkWrapper';
    const btn = document.createElement('button');
    btn.className = 'ghost';
    btn.textContent = t.iDontKnow || 'Не знаю';
    btn.addEventListener('click', onIDontKnow);
    wrap.appendChild(btn);
    D.optionsRow.appendChild(wrap);
  }

  // ─ mistakes pool (same source/dictLang only) ─
  function getMistakesDistractorPool(currentWord) {
    const out = [];
    const seen = new Set();
    const push = (w) => {
      if (!w || !w.id || String(w.id) === String(currentWord.id)) return;
      const label = ((App.settings.lang === 'ru') ? (w.ru || w.uk) : (w.uk || w.ru)) || w.translation || w.meaning;
      if (!label) return;
      const key = String(w.id) + '::' + String(label);
      if (seen.has(key)) return;
      seen.add(key);
      out.push(w);
    };

    let srcKey = null;
    try { srcKey = (App.Mistakes && App.Mistakes.sourceKeyFor) ? App.Mistakes.sourceKeyFor(currentWord.id) : (currentWord._mistakeSourceKey || null); } catch (_) {}
    const dictLang = langOfKey(srcKey) || null;

    if (srcKey) {
      const srcDeck = App.Decks.resolveDeckByKey(srcKey) || [];
      for (let i = 0; i < srcDeck.length; i++) push(srcDeck[i]);
    }

    if (out.length < 12 && dictLang) {
      const keys = (App.Decks && App.Decks.builtinKeys) ? App.Decks.builtinKeys() : Object.keys(window.decks || {});
      for (let k of keys) {
        if (langOfKey(k) !== dictLang) continue;
        if (k === srcKey) continue;
        const d = App.Decks.resolveDeckByKey(k) || [];
        for (let i = 0; i < d.length; i++) push(d[i]);
        if (out.length >= 24) break;
      }
    }

    // mistakes deck (already filtered by dictLang/uiLang on module side)
    if (out.length < 24 && App.Mistakes && typeof App.Mistakes.deck === 'function') {
      const arr = App.Mistakes.deck() || [];
      for (let i = 0; i < arr.length; i++) push(arr[i]);
    }

    return out;
  }

  // ─ determine endless and pick index ─
  function allLearned(sub, key){
    const max = App.Trainer.starsMax();
    if (key === 'mistakes' && App.Mistakes && App.Mistakes.getStars){
      for (let i=0;i<sub.length;i++){
        const w = sub[i];
        const sk = w._mistakeSourceKey || (App.Mistakes.sourceKeyFor && App.Mistakes.sourceKeyFor(w.id));
        if ((App.Mistakes.getStars(sk, w.id) || 0) < max) return false;
      }
      return true;
    }
    const stars = (App.state && App.state.stars) || {};
    for (let i=0;i<sub.length;i++){ const w=sub[i]; if ((stars[w.id]||0) < max) return false; }
    return true;
  }

  function pickIndexWithFallback(sub, key) {
    if (!Array.isArray(sub) || sub.length === 0) return -1;
    if (isEndlessDict(key) && allLearned(sub, key)) {
      return Math.floor(Math.random() * sub.length); // endless: keep training same set
    }
    return App.Trainer.sampleNextIndexWeighted(sub);
  }

  // ─ render & stats ─
  function renderStars() {
    const w = current();
    const key = (App.dictRegistry && App.dictRegistry.activeKey) || null;
    const max = App.Trainer.starsMax();
    let score = 0;
    if (key === 'mistakes' && App.Mistakes && App.Mistakes.getStars){
      const sk = w._mistakeSourceKey || (App.Mistakes.sourceKeyFor && App.Mistakes.sourceKeyFor(w.id));
      score = App.Mistakes.getStars(sk, w.id);
    } else {
      score = (App.state.stars[w.id] || 0);
    }
    score = Math.max(0, Math.min(max, score));
    const host = D.starsEl; if (!host) return;
    host.innerHTML = '';
    for (let i = 0; i < max; i++) {
      const s = document.createElement('span');
      s.className = 'starIcon' + (i < score ? ' filled' : '');
      s.textContent = '★';
      host.appendChild(s);
    }
  }

  function updateStats() {
    const t = App.i18n ? App.i18n() : { totalWords: 'Всего слов', learned: 'Выучено' };
    const key = (App.dictRegistry && App.dictRegistry.activeKey) || null;
    const fullDeck = (App.Decks && App.Decks.resolveDeckByKey) ? (App.Decks.resolveDeckByKey(key) || []) : [];
    const repeats = (App.Trainer && typeof App.Trainer.starsMax === 'function') ? App.Trainer.starsMax() : ((App.state && App.state.repeats) || 3);
    let learned = 0;

    if (key === 'mistakes' && App.Mistakes && App.Mistakes.getStars){
      for (let i=0;i<fullDeck.length;i++){
        const w = fullDeck[i]; if(!w) continue;
        const sk = w._mistakeSourceKey || (App.Mistakes.sourceKeyFor && App.Mistakes.sourceKeyFor(w.id));
        if ((App.Mistakes.getStars(sk, w.id) || 0) >= repeats) learned++;
      }
    } else {
      const starsMap = (App.state && App.state.stars) || {};
      for (let i = 0; i < fullDeck.length; i++) if ((starsMap[fullDeck[i].id] || 0) >= repeats) learned++;
    }

    if (App.DOM && App.DOM.statsBar) App.DOM.statsBar.textContent = `${t.totalWords || 'Всего слов'}: ${fullDeck.length} / ${(t.learned || 'Выучено')}: ${learned}`;
  }

  function renderCard(force = false) {
    if (document.activeElement && document.activeElement.blur) { try { document.activeElement.blur(); } catch (e) {} }
    const key = (App.dictRegistry && App.dictRegistry.activeKey) || null;
    const deck = getActiveDeck();
    if (!deck.length) {
      if (key === 'mistakes') {
        if (D.wordEl) D.wordEl.textContent = '—';
        if (D.hintEl) D.hintEl.textContent = '—';
        if (D.optionsRow) D.optionsRow.innerHTML = '';
        renderStars(); updateStats();
        return;
      }
      if (D.wordEl) D.wordEl.textContent = '—';
      if (D.hintEl) D.hintEl.textContent = '—';
      if (D.optionsRow) D.optionsRow.innerHTML = '';
      renderStars(); updateStats();
      return;
    }

    if (force || App.state.index === App.state.lastIndex) {
      const b = App.Sets ? App.Sets.activeBounds() : { start: 0, end: deck.length };
      const sub = deck.slice(b.start, b.end);
      const picked = pickIndexWithFallback(sub, key);
      if (picked >= 0) App.state.index = b.start + picked;
    }

    const w = current();
    if (App.state.lastShownWordId !== w.id) {
      App.state.totals.shown += 1;
      App.state.lastShownWordId = w.id;
      App.state.lastSeen[w.id] = Date.now();
      App.saveState();
      // Не авто-адвансим в endless-словарях
      if (!isEndlessDict(key)) {
        try{ if(App.Sets && App.Sets.checkCompletionAndAdvance) App.Sets.checkCompletionAndAdvance(); }catch(e){}
      }
    }

    const t = App.i18n();
    const isReverse = decideModeForWord(w);

    renderStars();
    D.optionsRow.innerHTML = '';

    // Build pools with proper labels and dedup handled in drawOptions()
    if (!isReverse) {
      if (D.wordEl) D.wordEl.textContent = w.word;
      let poolWords;
      if (key === 'mistakes') {
        poolWords = getMistakesDistractorPool(w)
          .map(x => (App.settings.lang === 'ru') ? (x.ru || x.uk || x.translation || x.meaning) : (x.uk || x.ru || x.translation || x.meaning))
          .filter(Boolean);
      } else {
        poolWords = deck.filter(x => x.id !== w.id)
          .map(x => (App.settings.lang === 'ru') ? (x.ru || x.uk || x.translation || x.meaning) : (x.uk || x.ru || x.translation || x.meaning))
          .filter(Boolean);
      }
      const correct = (App.settings.lang === 'ru') ? (w.ru || w.uk || w.translation || w.meaning || '') : (w.uk || w.ru || w.translation || w.meaning || '');
      drawOptions(correct, poolWords);
    } else {
      if (D.wordEl) D.wordEl.textContent = (App.settings.lang === 'ru') ? (w.ru || w.uk || w.translation || w.meaning || '') : (w.uk || w.ru || w.translation || w.meaning || '');
      let poolWords;
      if (key === 'mistakes') {
        poolWords = getMistakesDistractorPool(w).map(x => x.word).filter(Boolean);
      } else {
        poolWords = deck.filter(x => x.id !== w.id).map(x => x.word).filter(Boolean);
      }
      const correct = w.word;
      drawOptions(correct, poolWords);
    }

    if (D.hintEl) D.hintEl.textContent = t.choose;

    if (D.favBtn) {
      // Сердечко неактивно в fav и mistakes
      D.favBtn.disabled = (key === 'fav' || key === 'favorites' || key === 'mistakes');
      const dictKey = (key === 'mistakes')
        ? ((w && (w._mistakeSourceKey || (App.Mistakes && App.Mistakes.sourceKeyFor && App.Mistakes.sourceKeyFor(w.id)))) || 'mistakes')
        : key;
      D.favBtn.textContent = (App.isFavorite && App.isFavorite(dictKey, w.id)) ? '♥' : '♡';
    }

    addIDontKnowButton();
    updateStats();
  }

  // ─ add to mistakes with favorite priority ─
  function addToMistakesOnFailure(word) {
    if (!word) return;
    try {
      // приоритет избранного: если слово в избранном для своего sourceKey — не добавляем в МО
      const sk = (word._mistakeSourceKey || (App.Mistakes && App.Mistakes.sourceKeyFor && App.Mistakes.sourceKeyFor(word.id)) || (App.dictRegistry && App.dictRegistry.activeKey));
      if (App.isFavorite && App.isFavorite(sk, word.id)) return;

      const active = (App && App.dictRegistry && App.dictRegistry.activeKey) || null;
      let sourceKey;
      if (active === 'mistakes') {
        sourceKey = sk || 'mistakes';
      } else {
        sourceKey = active;
      }
      if (App && App.Mistakes && typeof App.Mistakes.add === 'function') {
        App.Mistakes.add(String(word.id), word, sourceKey);
      }
    } catch (e) {}
  }

  // ─ answers ─
  function onChoice(btn, correct) {
    const w = current();
    const key = (App.dictRegistry && App.dictRegistry.activeKey) || null;
    const max = App.Trainer.starsMax();

    if (correct) {
      btn.classList.add('correct');
      D.optionsRow.querySelectorAll('button.optionBtn').forEach(b => b.disabled = true);

      if (key === 'mistakes' && App.Mistakes && App.Mistakes.getStars){
        const sk = w._mistakeSourceKey || (App.Mistakes.sourceKeyFor && App.Mistakes.sourceKeyFor(w.id));
        const cur = App.Mistakes.getStars(sk, w.id) || 0;
        App.Mistakes.setStars(sk, w.id, Math.max(0, Math.min(max, cur+1)));
      } else {
        const cur = Math.max(0, Math.min(max, App.state.stars[w.id] || 0));
        App.state.stars[w.id] = Math.max(0, Math.min(max, cur+1));
        App.state.successes[w.id] = (App.state.successes[w.id] || 0) + 1;
      }

      App.saveState();
      if (!isEndlessDict(key)) {
        try{ if(App.Sets && App.Sets.checkCompletionAndAdvance) App.Sets.checkCompletionAndAdvance(); }catch(e){}
      }
      renderStars();
      updateStats();

      // milestones only "learned" left as-is — не трогаем

      setTimeout(nextWord, 500);
      return;
    }

    // wrong
    btn.classList.add('wrong');
    btn.disabled = true;

    if (key === 'mistakes' && App.Mistakes && App.Mistakes.getStars){
      const sk = w._mistakeSourceKey || (App.Mistakes.sourceKeyFor && App.Mistakes.sourceKeyFor(w.id));
      const cur = App.Mistakes.getStars(sk, w.id) || 0;
      App.Mistakes.setStars(sk, w.id, Math.max(0, Math.min(max, cur-1)));
    } else {
      const cur = Math.max(0, Math.min(max, App.state.stars[w.id] || 0));
      App.state.stars[w.id] = Math.max(0, Math.min(max, cur-1));
    }

    App.state.totals.errors += 1;
    App.state.totals.sessionErrors = (App.state.totals.sessionErrors || 0) + 1;

    // приоритет избранного: если слово уже в избранном — не добавляем в МО
    if (!(App.isFavorite && App.isFavorite((w._mistakeSourceKey || (App.Mistakes && App.Mistakes.sourceKeyFor && App.Mistakes.sourceKeyFor(w.id)) || (App.dictRegistry && App.dictRegistry.activeKey)), w.id))) {
      addToMistakesOnFailure(w);
    }

    App.saveState();
    if (!isEndlessDict(key)) {
      try{ if(App.Sets && App.Sets.checkCompletionAndAdvance) App.Sets.checkCompletionAndAdvance(); }catch(e){}
    }
    renderStars();
    updateStats();
  }

  function onIDontKnow() {
    const w = current();
    const c = D.optionsRow.querySelector('button.optionBtn[data-correct="1"]');
    if (c) c.classList.add('correct');
    D.optionsRow.querySelectorAll('button.optionBtn').forEach(b => b.disabled = true);
    const key = (App.dictRegistry && App.dictRegistry.activeKey) || null;
    const max = App.Trainer.starsMax();

    if (key === 'mistakes' && App.Mistakes && App.Mistakes.getStars){
      const sk = w._mistakeSourceKey || (App.Mistakes.sourceKeyFor && App.Mistakes.sourceKeyFor(w.id));
      const cur = App.Mistakes.getStars(sk, w.id) || 0;
      App.Mistakes.setStars(sk, w.id, Math.max(0, Math.min(max, cur-1)));
    } else {
      const cur = Math.max(0, Math.min(max, App.state.stars[w.id] || 0));
      App.state.stars[w.id] = Math.max(0, Math.min(max, cur-1));
    }

    App.state.totals.errors += 1;
    App.state.totals.sessionErrors = (App.state.totals.sessionErrors || 0) + 1;

    // приоритет избранного: если слово в избранном — не добавляем в МО
    if (!(App.isFavorite && App.isFavorite((w._mistakeSourceKey || (App.Mistakes && App.Mistakes.sourceKeyFor && App.Mistakes.sourceKeyFor(w.id)) || (App.dictRegistry && App.dictRegistry.activeKey)), w.id))) {
      addToMistakesOnFailure(w);
    }

    App.saveState();
    if (!isEndlessDict(key)) {
      try{ if(App.Sets && App.Sets.checkCompletionAndAdvance) App.Sets.checkCompletionAndAdvance(); }catch(e){}
    }
    renderStars();
    updateStats();
    setTimeout(function () { nextWord(); }, 700);
  }

  // ─ sets bar ─
  App.renderSetsBar = function () {
    const host = document.getElementById('setsBar');
    if (!host) return;
    host.innerHTML = '';
    const total = (App.Sets && App.Sets.setTotalCount) ? App.Sets.setTotalCount() : 1;
    const active = (App.Sets && App.Sets.getActiveSetIndex) ? App.Sets.getActiveSetIndex() : 0;
    for (let i = 0; i < total; i++) {
      const btn = document.createElement('button');
      btn.className = 'setTile' + (i === active ? ' active' : '') + (App.Sets.isSetDone(i) ? ' done' : '');
      btn.setAttribute('type', 'button');
      btn.setAttribute('aria-pressed', i === active ? 'true' : 'false');
      if (i === active) btn.setAttribute('aria-current','true');
      btn.textContent = (i + 1);
      btn.addEventListener('click', () => {
        App.Sets.setActiveSetIndex(i);
        App.switchToSetImmediate();
      });
      host.appendChild(btn);
    }
    renderDictTitle();
    renderSetStats();
  };

  App.switchToSetImmediate = function () {
    const b = App.Sets.activeBounds();
    if (App.state.index < b.start || App.state.index >= b.end) App.state.index = b.start;
    renderCard(true);
    renderSetStats();
    App.saveState && App.saveState();
  };

  // ─ navigation ─
  function nextWord() {
    App.state.lastIndex = App.state.index;
    const key = (App.dictRegistry && App.dictRegistry.activeKey) || null;
    const b = App.Sets ? App.Sets.activeBounds() : { start: 0, end: getActiveDeck().length };
    const full = (App.Decks.resolveDeckByKey(key) || []);
    const sub = full.slice(b.start, b.end);
    if (!sub.length) { renderCard(true); return; }
    const picked = pickIndexWithFallback(sub, key);
    if (picked < 0) { renderCard(true); return; }
    App.state.index = b.start + picked;
    renderCard(true);
  }

  // ─ favorites ─
  function toggleFav() {
    const w = current();
    const activeKey = (App.dictRegistry && App.dictRegistry.activeKey) || null;
    // Если мы в mistakes — используем sourceKey слова, а не 'mistakes'
    const dictKey = (activeKey === 'mistakes')
      ? ((w && (w._mistakeSourceKey || (App.Mistakes && App.Mistakes.sourceKeyFor && App.Mistakes.sourceKeyFor(w.id)))) || 'mistakes')
      : activeKey;

    App.toggleFavorite && App.toggleFavorite(dictKey, w.id);
    if (D.favBtn) {
      D.favBtn.textContent = (App.isFavorite && App.isFavorite(dictKey, w.id)) ? '♥' : '♡';
      D.favBtn.style.transform = 'scale(1.2)';
      setTimeout(() => { D.favBtn.style.transform = 'scale(1)'; }, 140);
    }
    // Перерисовать списки — так появится/обновится «Избранное»
    if (typeof App.renderSetsBar === 'function') App.renderSetsBar();
  }

  // ─ dicts list, flags, bootstrap etc. (минимальные изменения) ─
  function renderDictList() {
    const host = D.dictListHost;
    if (!host) return;
    host.innerHTML = '';

    (function appendMistakesRowFirst() {
      try {
        const row = makeDictRow('mistakes');
        if (!row) return;
        host.appendChild(row);
        let cnt = 0;
        if (App.Mistakes && typeof App.Mistakes.count === 'function') cnt = App.Mistakes.count();
        if (cnt < 4) {
          row.classList.add('disabled');
          row.setAttribute('aria-disabled', 'true');
        }
      } catch (e) {}
    })();

    if (canShowFav()) host.appendChild(makeDictRow('fav'));

    (function(){
      const all = App.Decks.builtinKeys();
      const lg = (App.settings && App.settings.dictsLangFilter) || null;
      let keys = all;
      if (lg) keys = all.filter(k => keyLang(k) === lg);
      keys = _sortKeysByCategory(keys);
      keys.forEach(k => host.appendChild(makeDictRow(k)));
    })();

    for (const k of Object.keys(App.dictRegistry.user || {})) host.appendChild(makeDictRow(k));
  }

  function canShowFav() {
    try {
      App.migrateFavoritesToV2 && App.migrateFavoritesToV2();
      const v2 = (App.state && App.state.favorites_v2) || {};
      let cnt = 0; Object.keys(v2).forEach(k => { cnt += Object.keys(v2[k] || {}).filter(x => v2[k][x]).length; });
      return cnt >= 4;
    } catch (e) { return false; }
  }

  function makeDictRow(key) {
    const words = App.Decks.resolveDeckByKey(key) || [];
    const row = document.createElement('div');
    row.className = 'dictRow' + (key === App.dictRegistry.activeKey ? ' active' : '');
    row.dataset.key = key;

    const flag = document.createElement('div');
    flag.className = 'dictFlag';
    if (key === 'mistakes') flag.textContent = '⚠️';
    else flag.textContent = App.Decks.flagForKey(key, words);

    const name = document.createElement('div');
    name.className = 'dictName';
    if (key === 'mistakes') {
      const t = (typeof App.i18n === 'function') ? App.i18n() : null;
      name.textContent = (t && t.mistakesName) ? t.mistakesName : 'Мои ошибки';
    } else if (key === 'fav' || key === 'favorites') {
      name.textContent = (App.settings.lang === 'ru') ? 'Избранное' : 'Обране';
    } else {
      name.textContent = App.Decks.resolveNameByKey(key);
    }
    name.title = name.textContent;

    const actions = document.createElement('div');
    actions.className = 'dictActions';

    const prevBtn = document.createElement('button');
    prevBtn.className = 'iconOnly';
    prevBtn.title = (App.i18n().ttPreview || 'Предпросмотр');
    prevBtn.textContent = '👁️';
    prevBtn.addEventListener('click', (e) => { e.stopPropagation(); App.Decks.openPreview(words, name.textContent); });
    actions.appendChild(prevBtn);

    if (key === 'mistakes') {
      const delBtn = document.createElement('button');
      delBtn.className = 'iconOnly';
      delBtn.title = (App.settings.lang === 'ru') ? 'Очистить «Мои ошибки»' : 'Очистити «Мої помилки»';
      delBtn.textContent = '🗑️';
      delBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const msg = (App.settings.lang === 'ru') ? 'Очистить «Мои ошибки» для активного языка? Это действие нельзя отменить.' : 'Очистити «Мої помилки» для активної мови? Дію не можна скасувати.';
        if (!confirm(msg)) return;
        if (App.Mistakes && typeof App.Mistakes.clearActive==='function') App.Mistakes.clearActive();
        renderDictList(); App.renderSetsBar && App.renderSetsBar(); renderCard(true); updateStats();
      });
      actions.appendChild(delBtn);
    }

    if (key === 'fav' || key === 'favorites') {
      const delBtn = document.createElement('button');
      delBtn.className = 'iconOnly';
      delBtn.title = (App.settings.lang === 'ru') ? 'Очистить «Избранное»' : 'Очистити «Обране»';
      delBtn.textContent = '🗑️';
      delBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const msg = (App.settings.lang === 'ru') ? 'Очистить «Избранное»? Это действие нельзя отменить.' : 'Очистити «Обране»? Дію не можна скасувати.';
        if (!confirm(msg)) return;
        App.clearFavoritesAll && App.clearFavoritesAll();
        App.dictRegistry.activeKey = App.Decks.pickDefaultKey();
        App.saveDictRegistry();
        renderDictList(); App.renderSetsBar(); renderCard(true); updateStats();
      });
      actions.appendChild(delBtn);
    }

    row.appendChild(flag);
    row.appendChild(name);
    row.appendChild(actions);

    row.addEventListener('click', () => {
      if (row.classList.contains('disabled')) return;
      App.dictRegistry.activeKey = key;
      App.saveDictRegistry();

      App.state.index = 0;
      App.state.lastIndex = -1;
      renderDictList();
      App.renderSetsBar();
      renderCard(true);
      updateStats();
    });

    return row;
  }

  const FLAG_EMOJI = { ru:'🇷🇺', uk:'🇺🇦', en:'🇬🇧', de:'🇩🇪', es:'🇪🇸', fr:'🇫🇷', it:'🇮🇹', pl:'🇵🇱', sr:'🇷🇸', tr:'🇹🇷' };
  App.renderLangFlags = function(){
    if (!D.langFlags) return;
    const set = new Set();
    try {
      const keys = (App.Decks && typeof App.Decks.builtinKeys === 'function')
        ? App.Decks.builtinKeys()
        : Object.keys(window.decks || {});
      keys.forEach(k => {
        const m = String(k||'').match(/^([a-z]{2})_/i);
        const lg = m ? m[1].toLowerCase() : null;
        if (lg) set.add(lg);
      });
    } catch(_) {}
    const langs = Array.from(set);
    D.langFlags.innerHTML = '';
    if (!langs.length) return;
    const active = App.settings.dictsLangFilter || null;
    langs.forEach(lg => {
      const b = document.createElement('button');
      b.className = 'flagBtn' + ((active===lg)?' active':'');
      b.title = (App.i18n()['lang_'+lg] || lg.toUpperCase());
      b.textContent = FLAG_EMOJI[lg] || lg.toUpperCase();
      b.addEventListener('click', () => {
        App.settings.dictsLangFilter = lg;
        App.saveSettings && App.saveSettings(App.settings);
        renderDictList();
        App.renderLangFlags();
      });
      D.langFlags.appendChild(b);
    });
  };

  // bootstrap/bindings
  const _origBootstrap = App.bootstrap || function(){};
  App.bootstrap = function () {
    _origBootstrap();
    if (!App.state || !App.state.totals) App.state.totals = {};
    App.state.totals.sessionErrors = 0;

    if (!App.dictRegistry.activeKey) { App.dictRegistry.activeKey = App.Decks.pickDefaultKey(); App.saveDictRegistry(); }

    applyLang();
    App.applyTheme && App.applyTheme();
    bindHeaderButtons();
    renderCard(true);
  };

  function applyLang() {
    const t = App.i18n();
    if (D.titleEl && D.titleEl.firstChild) D.titleEl.firstChild.textContent = (t.appTitle || 'App') + ' ';
    if (D.appVerEl) D.appVerEl.textContent = 'v' + (App.APP_VER || '1.0.0');
    if (D.taglineEl) D.taglineEl.textContent = t.tagline || '';
    if (D.dictsBtn) D.dictsBtn.title = t.dictsHeader || 'Словари';
    renderDictList();
    App.renderSetsBar && App.renderSetsBar();
    updateStats();
  }

  function openModal() { if (D.modal) D.modal.classList.remove('hidden'); var t=App.i18n?App.i18n():null; var el=document.getElementById('modalTitle'); if(el&&t&&t.modalTitle) el.textContent=t.modalTitle; }
  function closeModal() { if (D.modal) D.modal.classList.add('hidden'); }

  function bindHeaderButtons() {
    if (D.langToggleBtn) {
      D.langToggleBtn.addEventListener('click', () => {
        App.settings.lang = (App.settings.lang === 'ru') ? 'uk' : 'ru';
        D.langToggleBtn.textContent = (App.settings.lang === 'ru') ? '🇷🇺' : '🇺🇦';
        App.saveSettings(App.settings);
        applyLang();
        App.applyTheme && App.applyTheme();
        renderCard(true);
      });
    }
    if (D.themeToggleBtn) {
      const updateIcon = () => {
        const mode = document.documentElement.getAttribute('data-theme');
        D.themeToggleBtn.textContent = (mode === 'dark') ? '🌙' : '🌞';
      };
      D.themeToggleBtn.addEventListener('click', () => {
        const cur = document.documentElement.getAttribute('data-theme') || 'light';
        const next = (cur === 'dark') ? 'light' : 'dark';
        App.settings.theme = next;
        App.saveSettings(App.settings);
        App.applyTheme && App.applyTheme();
        updateIcon();
      });
      updateIcon();
    }
    if (D.dictsBtn) { D.dictsBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); openModal(); App.renderLangFlags && App.renderLangFlags(); }); }
    if (D.okBtn) { D.okBtn.addEventListener('click', () => { closeModal(); }); }
    if (D.backdrop) { D.backdrop.addEventListener('click', () => { closeModal(); }); }
    if (D.favBtn) { D.favBtn.addEventListener('click', toggleFav); }
  }
})();

window.UIBus = (function(){
  const map = {};
  return {
    on: function(evt, cb){ (map[evt] ||= []).push(cb); },
    off: function(evt, cb){ if(!map[evt]) return; map[evt] = map[evt].filter(x=>x!==cb); },
    emit: function(evt, data){ (map[evt]||[]).forEach(cb=>{ try{ cb(data); }catch(_){} }); }
  };
})();

(function(){

})();

(function(){
  const App = window.App||{};
  if (App.Sets && typeof App.Sets.setActiveSetIndex === 'function'){
    const _orig = App.Sets.setActiveSetIndex;
    App.Sets.setActiveSetIndex = function(i){
      _orig.call(App.Sets, i);
      try{ UIState.syncTrainer(); }catch(e){}
      try{ App.renderSetsBar && App.renderSetsBar(); }catch(e){}
      try{ (typeof renderSetStats==='function'?renderSetStats:App.renderSetStats)(); }catch(e){}
      try{ typeof renderCard==='function' && renderCard(true); }catch(e){}
      try{ typeof updateStats==='function' && updateStats(); }catch(e){}
      try{ window.UIBus && UIBus.emit('sets:changed', { key: App.dictRegistry && App.dictRegistry.activeKey, index: UIState.activeSetIndex }); }catch(e){}
    };
  }
  if (App.Sets && typeof App.Sets.checkCompletionAndAdvance === 'function'){
    const _check = App.Sets.checkCompletionAndAdvance;
    App.Sets.checkCompletionAndAdvance = function(){
      const res = _check.call(App.Sets);
      try{ UIState.syncTrainer(); }catch(e){}
      try{ App.renderSetsBar && App.renderSetsBar(); }catch(e){}
      try{ (typeof renderSetStats==='function'?renderSetStats:App.renderSetStats)(); }catch(e){}
      try{ typeof updateStats==='function' && updateStats(); }catch(e){}
      return res;
    };
  }
  if (App.Mistakes && typeof App.Mistakes.add === 'function'){
    const _add = App.Mistakes.add;
    App.Mistakes.add = function(id, card, sourceKey){
      try{
        if (arguments.length===2 && typeof card==='string'){
          return _add.call(App.Mistakes, id, null, card);
        }
        return _add.call(App.Mistakes, id, card||null, sourceKey || (App.dictRegistry && App.dictRegistry.activeKey));
      }catch(e){ try{ return _add.apply(App.Mistakes, arguments); }catch(_){} }
    };
  }
})();

(function(){
  function afterAnswer(){
    try{
      if (window.App && App.Sets && typeof App.Sets.checkCompletionAndAdvance === 'function'){
        App.Sets.checkCompletionAndAdvance();
      }
    }catch(e){}
    try{ if (window.App && App.Stats && App.Stats.recomputeAndRender) App.Stats.recomputeAndRender(); }catch(e){}
  }
  function afterSetChange(){
    try{ if (window.App && App.Stats && App.Stats.recomputeAndRender) App.Stats.recomputeAndRender(); }catch(e){}
  }
  function hook(name, fn){
    var w = window;
    if (typeof w[name] !== 'function') return;
    var orig = w[name];
    w[name] = function(){
      var r = orig.apply(this, arguments);
      try{ fn(); }catch(e){}
      return r;
    };
  }
  hook('onChoice', afterAnswer);
  hook('onIDontKnow', afterAnswer);
  hook('nextWord', afterAnswer);

  // wrap set change
  try{
    if (window.App && App.Sets && typeof App.Sets.setActiveSetIndex === 'function'){
      var _set = App.Sets.setActiveSetIndex;
      App.Sets.setActiveSetIndex = function(i){
        var r = _set.apply(this, arguments);
        try{ afterSetChange(); }catch(e){}
        return r;
      };
    }
  }catch(e){}
})();

(function(){
  var App = window.App || (window.App = {});

  function uiLang(){ return (App.settings && App.settings.lang) || 'ru'; }
  function activeKey(){ return (App.dictRegistry && App.dictRegistry.activeKey) || null; }

  function labelOf(word){
    if (!word) return '';
    var ui = uiLang();
    var txt = (ui === 'ru') ? (word.ru || word.uk) : (word.uk || word.ru);
    txt = txt || word.translation || word.meaning || word.value || '';
    return String(txt||'').trim();
  }

  function resolveDeck(key){
    try{ return (App.Decks && App.Decks.resolveDeckByKey) ? (App.Decks.resolveDeckByKey(key) || []) : []; }catch(e){ return []; }
  }
  function mistakesDeck(){
    try{ return (App.Mistakes && App.Mistakes.deck) ? (App.Mistakes.deck() || []) : []; }catch(e){ return []; }
  }

  function uniqPush(arr, item, used){
    var txt = item && item.text;
    if (!txt || used.has(txt)) return false;
    arr.push(item); used.add(txt); return true;
  }

  function buildOptionsMistakes(word){
    var options = [];
    var used = new Set();

    // 1) correct option
    var correctText = labelOf(word) || String(word.word||'').trim();
    uniqPush(options, { id:String(word.id), text: correctText, isCorrect:true }, used);

    // 2) pool from mistakes (full cards)
    var pool = mistakesDeck().slice();
    for (var i = pool.length - 1; i >= 0; i--){
      if (String(pool[i].id) === String(word.id)) pool.splice(i,1);
    }
    for (var i=0; i<pool.length && options.length<4; i++){
      var txt = labelOf(pool[i]);
      if (!txt) continue;
      uniqPush(options, { id:String(pool[i].id), text:txt, isCorrect:false }, used);
    }

    // 3) top-up from same source deck
    var dk = word._mistakeSourceKey || activeKey();
    var full = resolveDeck(dk);
    for (var j=0; j<full.length && options.length<4; j++){
      var w = full[j]; if (String(w.id) === String(word.id)) continue;
      var txt2 = labelOf(w); if (!txt2) continue;
      uniqPush(options, { id:String(w.id), text:txt2, isCorrect:false }, used);
    }

    // 4) shuffle
    for (var k = options.length - 1; k > 0; k--){
      var m = Math.floor(Math.random()*(k+1));
      var tmp = options[k]; options[k]=options[m]; options[m]=tmp;
    }
    return options;
  }

  function sanitizeRegular(word, options){
    var used = new Set();
    var out = [];

    var correctText = labelOf(word) || String(word.word||'').trim();
    var hasCorrect = false;

    function pushOpt(opt){
      var txt = (opt && String(opt.text||'').trim()) || '';
      if (!txt || used.has(txt)) return;
      out.push({ id:String(opt.id||''), text:txt, isCorrect:!!opt.isCorrect });
      used.add(txt);
    }

    if (Array.isArray(options)) {
      for (var i=0;i<options.length;i++){
        var o = options[i] || {};
        if (o.isCorrect) hasCorrect = true;
        if (!o.text){
          if (o.isCorrect) o.text = correctText;
          else if (o.word) o.text = labelOf(o.word);
        }
        pushOpt(o);
      }
    }

    if (!hasCorrect){
      pushOpt({ id:String(word.id), text:correctText, isCorrect:true });
    }

    // top-up to 4 from active deck
    var deck = resolveDeck(activeKey());
    for (var j=0; j<deck.length && out.length<4; j++){
      var w = deck[j]; if (String(w.id) === String(word.id)) continue;
      var txt = labelOf(w); if (!txt) continue;
      pushOpt({ id:String(w.id), text:txt, isCorrect:false });
    }

    while (out.length < 4){
      out.push({ id:'__stub_'+out.length, text: correctText, isCorrect: (out.length===0) });
    }

    // shuffle (keep at least one correct)
    var corrIdx = out.findIndex(function(o){ return o.isCorrect; });
    for (var k = out.length - 1; k > 0; k--){
      var m = Math.floor(Math.random()*(k+1));
      var tmp = out[k]; out[k]=out[m]; out[m]=tmp;
    }
    if (out.every(function(o){ return !o.isCorrect; })){
      out[0].isCorrect = true;
    }
    return out;
  }

  function install(){
    var original = null, where = null;
    var probes = [
      function(){ if (typeof window.buildOptionsFor === 'function') return { obj:window, key:'buildOptionsFor' }; },
      function(){ if (typeof window.buildOptions === 'function') return { obj:window, key:'buildOptions' }; },
      function(){ if (App && App.UI && typeof App.UI.buildOptions === 'function') return { obj:App.UI, key:'buildOptions' }; },
      function(){ if (App && App.Trainer && typeof App.Trainer.buildOptions === 'function') return { obj:App.Trainer, key:'buildOptions' }; },
      function(){ if (App && typeof App.buildOptions === 'function') return { obj:App, key:'buildOptions' }; }
    ];
    for (var i=0;i<probes.length;i++){
      var hit = null; try{ hit = probes[i](); }catch(e){}
      if (hit){ original = hit.obj[hit.key]; where = hit; break; }
    }

    function wrapper(word){
      if ((App.dictRegistry && App.dictRegistry.activeKey) === 'mistakes'){
        return buildOptionsMistakes(word);
      } else {
        var opts = original ? original.call(where.obj, word) : [];
        return sanitizeRegular(word, opts);
      }
    }

    if (where){
      where.obj[where.key] = wrapper;
    } else {
      // fallback: wrap renderOptions if builder unknown
      var origRender = null;
      if (typeof window.renderOptions === 'function'){
        origRender = window.renderOptions;
        window.renderOptions = function(word){
          var opts = sanitizeRegular(word, []);
          return origRender(opts);
        };
      }
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){ try{ install(); }catch(e){} });
  } else {
    try { install(); } catch(e){}
  }
})();

(function(){
  if (!window.App) window.App = {};
  var App = window.App;

  var LS_KEY = 'progress.v2'; // { stars:{dict:{set:{id:value}}}, successes:{...}, lastSeen:{...} }

  function load(){
    try{
      var raw = localStorage.getItem(LS_KEY);
      var st = raw ? JSON.parse(raw) : {};
      st.stars = st.stars || {};
      st.successes = st.successes || {};
      st.lastSeen = st.lastSeen || {};
      return st;
    }catch(e){ return {stars:{},successes:{},lastSeen:{}}; }
  }
  function save(st){
    try{ localStorage.setItem(LS_KEY, JSON.stringify(st)); }catch(e){}
  }

  function scope(){
    var key = (App.dictRegistry && App.dictRegistry.activeKey) || 'default';
    var setIndex = 0;
    try{
      if (App.Sets && typeof App.Sets.getActiveSetIndex === 'function'){
        setIndex = App.Sets.getActiveSetIndex()|0;
      } else if (App.Sets && App.Sets.state && App.Sets.state.activeByDeck && key in App.Sets.state.activeByDeck){
        setIndex = App.Sets.state.activeByDeck[key]|0;
      }
    }catch(e){}
    return { key: String(key), set: String(setIndex) };
  }

  function ensure2(obj, k1, k2){
    if (!obj[k1]) obj[k1] = {};
    if (!obj[k1][k2]) obj[k1][k2] = {};
    return obj[k1][k2];
  }

  function getFrom(bucket, prop){
    // поддержка как числовых, так и строковых ключей
    if (prop in bucket) return bucket[prop];
    var s = String(prop);
    if (s in bucket) return bucket[s];
    return 0;
  }

  function setTo(bucket, prop, value){
    var s = String(prop);
    bucket[s] = value; // нормализуем к строковому id
  }

  function makeProxy(field){
    var st = load();
    var shadow = Object.create(null); // локальная тень для ownKeys/has
    return new Proxy(shadow, {
      get: function(t, prop){
        if (prop === '__isProxy') return true;
        // служебное: чтобы Object.keys итерировал корректно
        if (prop === 'toJSON') return function(){ var s=scope(); return Object.assign({}, ensure2(st[field], s.key, s.set)); };
        var s = scope();
        var bucket = ensure2(st[field], s.key, s.set);
        return getFrom(bucket, prop);
      },
      set: function(t, prop, value){
        var s = scope();
        var bucket = ensure2(st[field], s.key, s.set);
        setTo(bucket, prop, value);
        save(st);
        // тень для корректных ownKeys/has
        t[String(prop)] = value;
        return true;
      },
      deleteProperty: function(t, prop){
        var s = scope();
        var bucket = ensure2(st[field], s.key, s.set);
        delete bucket[String(prop)];
        save(st);
        delete t[String(prop)];
        return true;
      },
      has: function(t, prop){
        var s = scope();
        var bucket = ensure2(st[field], s.key, s.set);
        return (prop in bucket) || (String(prop) in bucket);
      },
      ownKeys: function(t){
        var s = scope();
        var bucket = ensure2(st[field], s.key, s.set);
        try { return Object.keys(bucket); } catch(e){ return []; }
      },
      getOwnPropertyDescriptor: function(t, prop){
        return { enumerable: true, configurable: true };
      }
    });
  }

  // Инициализация прокси (идемпотентно)
  App.state = App.state || {};
  if (!App.state.stars || !App.state.stars.__isProxy)  App.state.stars     = makeProxy('stars');
  if (!App.state.successes || !App.state.successes.__isProxy) App.state.successes = makeProxy('successes');
  if (!App.state.lastSeen || !App.state.lastSeen.__isProxy)   App.state.lastSeen  = makeProxy('lastSeen');
  App.state.stars.__isProxy = true;
  App.state.successes.__isProxy = true;
  App.state.lastSeen.__isProxy = true;
})();

(function(){
  var App = window.App || (window.App = {});
  App.Sets = App.Sets || {};

  var STORE = 'sets.done.v1';

  function load(){
    try{
      var raw = localStorage.getItem(STORE);
      var st = raw ? JSON.parse(raw) : {};
      return (st && typeof st === 'object') ? st : {};
    }catch(e){ return {}; }
  }
  function save(st){ try{ localStorage.setItem(STORE, JSON.stringify(st)); }catch(e){} }
  function activeKey(){ return (App.dictRegistry && App.dictRegistry.activeKey) || null; }

  App.Sets.getDone = function(key){
    key = key || activeKey();
    var st = load();
    return st[key] || [];
  };
  App.Sets.isDone = function(key, idx){
    if (typeof idx === 'undefined'){ idx = key; key = activeKey(); }
    var arr = App.Sets.getDone(key);
    return Array.isArray(arr) ? arr.indexOf(idx) >= 0 : false;
  };
  App.Sets.markDone = function(key, idx){
    if (typeof idx === 'undefined'){ idx = key; key = activeKey(); }
    if (key == null || typeof idx !== 'number') return;
    var st = load();
    var arr = st[key] || (st[key] = []);
    if (arr.indexOf(idx) === -1) arr.push(idx);
    save(st);
    try{ App.Sets.refreshDoneStyles && App.Sets.refreshDoneStyles(); }catch(e){}
  };

  (function injectCSS(){
    var css = ""
      + ".set-tile--done{ box-shadow: inset 0 0 0 2px var(--accent); border-color: var(--accent)!important; }"
      + ".set-tile--done::after{ content:'✓'; position:absolute; right:6px; top:6px; font-weight:700; font-size:12px; color:var(--accent); opacity:.85; }";
    var st = document.createElement('style');
    st.textContent = css;
    document.head.appendChild(st);
  })();

  function applyStyles(){
    try{
      var host = document.getElementById('setsBar');
      if (!host) return;
      var tiles = host.querySelectorAll('[data-set-index]');
      var done = App.Sets.getDone(activeKey());
      for (var j=0;j<tiles.length;j++){
        var el = tiles[j];
        var idx = parseInt(el.getAttribute('data-set-index'),10);
        if (done.indexOf(idx) >= 0){
          el.classList.add('set-tile--done');
          el.style.position = el.style.position || 'relative';
        } else {
          el.classList.remove('set-tile--done');
        }
      }
    }catch(e){}
  }

  App.Sets.refreshDoneStyles = applyStyles;

  (function patchRender(){
    var orig = App.renderSetsBar || window.renderSetsBar;
    if (typeof orig === 'function'){
      var wrapped = function(){
        var r = orig.apply(this, arguments);
        try{ applyStyles(); }catch(e){}
        return r;
      };
      App.renderSetsBar = wrapped;
      window.renderSetsBar = wrapped;
    }else{
      document.addEventListener('DOMContentLoaded', applyStyles);
    }
  })();

  if (App.Sets && typeof App.Sets.setActiveSetIndex === 'function'){
    var _origSet = App.Sets.setActiveSetIndex;
    App.Sets.setActiveSetIndex = function(i){
      var r = _origSet.apply(this, arguments);
      try{ applyStyles(); }catch(e){}
      return r;
    };
  }
})();

(function(){

if (App.switchToSetImmediate) {  return; }
App.switchToSetImmediate = function () {
    
  try { if (App.renderSetsBar) App.renderSetsBar(); } catch(e){} 
const b = App.Sets.activeBounds();
    if (App.state.index < b.start || App.state.index >= b.end) App.state.index = b.start;
    if(App.renderCard) App.renderCard(true); else if (typeof renderCard==='function') renderCard(true);
    if(App.renderSetStats) App.renderSetStats(); else if (typeof renderSetStats==='function') renderSetStats();
    App.saveState && App.saveState();
  }
})();

(function(){
  const App = window.App||{};
  App.settings = App.settings || {};
  if (!App.settings.dictsLangFilter) App.settings.dictsLangFilter = 'en';
  try{
    if (!App.dictRegistry || !App.dictRegistry.activeKey){
      const keys = Object.keys(window.decks || {});
      const en = keys.find(k => /^en[_-]/i.test(k));
      if (en){
        App.dictRegistry = App.dictRegistry || {};
        App.dictRegistry.activeKey = en;
        App.saveDictRegistry && App.saveDictRegistry();
      } else if (App.Decks && typeof App.Decks.pickDefaultKey==='function'){
        App.Decks.pickDefaultKey();
      }
    }
  }catch(e){}
  try{ UIState.syncTrainer(); }catch(e){}
  try{ typeof renderDictList==='function' && renderDictList(); }catch(e){}
  try{ App.renderSetsBar && App.renderSetsBar(); }catch(e){}
  try{ typeof renderSetStats==='function' && renderSetStats(); }catch(e){}
  try{ typeof renderCard==='function' && renderCard(true); }catch(e){}
  try{ typeof updateStats==='function' && updateStats(); }catch(e){}
})();

(function(){
  const A = ()=>window.App||{};
  function key(){ return (A().dictRegistry && A().dictRegistry.activeKey) || null; }
  function idx(){
    const k = key();
    return (A().Sets && A().Sets.state && A().Sets.state.activeByDeck && A().Sets.state.activeByDeck[k]) || 0;
  }
  function sync(){
    try{
      const k = key(); const i = idx();
      if (A().Trainer && typeof A().Trainer.setBatchIndex==='function'){
        A().Trainer.setBatchIndex(i, k);
      }
    }catch(e){}
  }
  window.UIState = {
    get activeDict(){ return key(); },
    set activeDict(v){ if (!A().dictRegistry) A().dictRegistry = {}; A().dictRegistry.activeKey = v; if (A().saveDictRegistry) A().saveDictRegistry(); },
    get activeSetIndex(){ return idx(); },
    setActiveSetIndex: function(i){ A().Sets && A().Sets.setActiveSetIndex && A().Sets.setActiveSetIndex(i); },
    syncTrainer: sync
  };
})();

(function(){
  window.App = window.App || {};
  var App = window.App;
  App.Stats = App.Stats || {};

  App.Stats.recomputeAndRender = function(){
    // если есть отдельная логика перерасчёта — можно добавить здесь,
    // но текущие рендеры уже читают состояния из App.Trainer/App.state.*
    try{ if (typeof renderSetStats === 'function') renderSetStats(); }catch(e){}
    try{ if (typeof updateStats === 'function') updateStats(); }catch(e){}
  };
})();

(function(){
  function refresh(){
    try{ if (typeof renderSetStats === 'function') renderSetStats(); }catch(e){}
    try{ if (typeof updateStats === 'function') updateStats(); }catch(e){}
  }
  function hook(name){
    var w = window;
    if (typeof w[name] !== 'function') return;
    var orig = w[name];
    w[name] = function(){
      var r = orig.apply(this, arguments);
      try{ refresh(); }catch(e){}
      return r;
    };
  }
  hook('onChoice');
  hook('onIDontKnow');
  hook('nextWord');

  try{
    if (window.App && App.Sets && typeof App.Sets.setActiveSetIndex === 'function'){
      var _set = App.Sets.setActiveSetIndex;
      App.Sets.setActiveSetIndex = function(i){
        var r = _set.apply(this, arguments);
        try{ refresh(); }catch(e){}
        return r;
      };
    }
  }catch(e){}
})();

(function(){

})();

(function(){
  const App = window.App = (window.App||{});
  App.isNightNow = function(){ const h = new Date().getHours(); return (h>=20 || h<7); };
  App.applyTheme = function(){
    let mode = App.settings?.theme || 'auto';
    if (mode==='auto') mode = App.isNightNow() ? 'dark' : 'light';
    document.documentElement.setAttribute('data-theme', mode);
    document.documentElement.setAttribute('lang', App.settings?.lang || 'uk');
  };
  let timer=null;
  App.scheduleThemeTick = function(){
    if (timer) clearInterval(timer);
    if ((App.settings?.theme||'auto')==='auto') timer = setInterval(App.applyTheme, 60*1000);
  };
})();

(function(){
  const App = window.App || (window.App = {});
  const P = App.Penalties = App.Penalties || {};
  const LS = 'penalties.v1';
  const now = ()=>Date.now();

  const defaultState = ()=>({ failures:{}, idk:{}, lastWrong:{} });
  P.state = defaultState();

  function load(){
    try{
      const raw = localStorage.getItem(LS);
      if (raw){
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === 'object') P.state = Object.assign(defaultState(), parsed);
      }
    }catch(e){}
  }
  function save(){
    try{ localStorage.setItem(LS, JSON.stringify(P.state)); }catch(e){}
  }

  P.onWrong = function(id){
    id = String(id);
    P.state.failures[id] = (P.state.failures[id]||0)+1;
    P.state.lastWrong[id] = now();
    save();
  };
  P.onIDK = function(id){
    id = String(id);
    P.state.idk[id] = (P.state.idk[id]||0)+1;
    P.state.lastWrong[id] = now();
    save();
  };

  function decay(ts){
    if (!ts) return 1.0;
    const days = (now()-ts)/(1000*60*60*24);
    const tau = 3.0; // 3 дня — полураспад влияния
    const factor = Math.exp(-days/tau);
    return Math.max(0.3, factor); // не опускаем влияние ниже 0.3
  }

  // Вес для сэмплера
  P.weightFor = function(id){
    id = String(id);
    const f = P.state.failures[id]||0;
    const k = P.state.idk[id]||0;
    const d = decay(P.state.lastWrong[id]);
    // базовая формула: 1 + 0.6*f + 0.4*k, с затуханием
    const w = (1 + 0.6*f + 0.4*k) * d;
    return Math.max(1, w);
  };

  // Вероятность реверса (добавка к базовой логике)
  P.reverseProbFor = function(id){
    id = String(id);
    const f = P.state.failures[id]||0;
    const d = decay(P.state.lastWrong[id]);
    const p = 0.05 + 0.03*f; // 5% базово, +3% за каждую ошибку
    return Math.max(0, Math.min(0.35, p * d));
  };

  load();
})();

(function(){
  const App = window.App || (window.App = {});
  if (!App.dictRegistry) App.dictRegistry = { activeKey:null, user:{} };

  function pickDefaultKey(){
    const keys = Object.keys(window.decks || {});
    if (!keys.length) {
      console.warn('[startup] Нет доступных словарей (window.decks пуст).');
      return null;
    }
    if (App.dictRegistry.activeKey && keys.includes(App.dictRegistry.activeKey))
      return App.dictRegistry.activeKey;
    try{
      const saved = localStorage.getItem('lexitron.activeKey');
      if (saved && keys.includes(saved)) {
        App.dictRegistry.activeKey = saved;
        return saved;
      }
    }catch(e){  }
    App.dictRegistry.activeKey = keys[0];
    return App.dictRegistry.activeKey;
  }

  function ensureDictionaries(){
    if (!window.decks || !Object.keys(window.decks).length){
      console.warn('[startup] Похоже, словари ещё не загружены (window.decks). Убедись, что dicts.js подключён раньше.');
    }
  }

  function start(){
    ensureDictionaries();
    pickDefaultKey();
    if (typeof App.bootstrap === 'function') {
      App.bootstrap();
    } else {
      console.error('[startup] App.bootstrap не найден. Проверь порядок подключения скриптов.');
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', start);
  } else {
    start();
  }
})();

(function(){
  // Map lang -> deck file
  function langFromKey(key){
    var m = (key||"").match(/^([a-z]{2})_/i);
    return m ? m[1].toLowerCase() : null;
  }
  // Ensure default deck key is {lang}_verbs
  function defaultDeckKeyForLang(lang){
    return (lang ? (lang.toLowerCase()+"_verbs") : "en_verbs");
  }
  // Public hook to switch active deck with lazy load
  App = window.App || {};
  var _setActiveDeckInternal = function(key){
    // Existing function that sets activeKey if present
    if (App && App.dictRegistry){
      App.dictRegistry.activeKey = key;
    } else {
      App.dictRegistry = App.dictRegistry || {}; 
      App.dictRegistry.activeKey = key;
    }
  };
  async function ensureDeckLoadedByKey(key){
    var lang = langFromKey(key) || "en";
    if (window.decks && window.decks[key]) return;
    // if file already loaded for this lang (deck.{lang}.js registers many keys), check a known key
    if (window.decks){
      for (var k in window.decks){
        if (langFromKey(k) === lang) return;
      }
    }
    var file = "deck."+lang+".js";
    await new Promise(function(res, rej){
      var s = document.createElement("script");
      s.async = true;
      s.src = file + (location.search.match(/v=([\w\.\-]+)/)?"" : "?v=1");
      s.onload = res; s.onerror = rej;
      document.head.appendChild(s);
    });
  }

  // Expose a single entry-point
  App.switchDeck = async function(key){
    if (!key){ key = defaultDeckKeyForLang(App.currentDictLang || "en"); }
    await ensureDeckLoadedByKey(key);
    _setActiveDeckInternal(key);
    // Try to re-render
    try{
      if (typeof renderDictTitle==='function') renderDictTitle();
      if (typeof renderCard==='function') renderCard(true);
      if (App.Stats && typeof App.Stats.recomputeAndRender==='function') App.Stats.recomputeAndRender();
    }catch(e){ console.error(e); }
  };

  // On startup: make sure i18n/lang are ready and pick default deck.
  document.addEventListener("DOMContentLoaded", function(){
    try{
      var uiLang = (App.settings && App.settings.uiLang) || "en";
      // determine current dictionary language: if user changed filter — use it, else english
      var dictLang = (App.currentDictLang) || "en";
      // pick default key
      var defKey = defaultDeckKeyForLang(dictLang);
      // lazy load and render
      App.switchDeck(defKey);
    }catch(e){ console.error(e); App.switchDeck("en_verbs"); }
  });

  // When user changes dictionary language filter externally, call:
  App.onDictLangChanged = function(newLang){
    App.currentDictLang = newLang || "en";
    var key = defaultDeckKeyForLang(App.currentDictLang);
    App.switchDeck(key);
  };
})();